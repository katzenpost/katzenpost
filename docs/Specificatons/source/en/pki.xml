<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article>
<article
  xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xlink="http://www.w3.org/1999/xlink" >
  <info>
    <title>Public Key Infrastructure</title>
    <authorgroup>
      <author>
        <personname>
          <firstname>Yawning</firstname>
          <surname>Angel</surname>
        </personname>
      </author>
      <author>
        <personname>
          <firstname>Claudia</firstname>
          <surname>Diaz</surname>
        </personname>
      </author>
      <author>
        <personname>
          <firstname>Ania</firstname>
          <surname>Piotrowska</surname>
        </personname>
      </author>
      <author>
        <personname>
          <firstname>David</firstname>
          <surname>Stainton</surname>
        </personname>
      </author>
      <author>
        <personname>
          <firstname></firstname>
          <surname>Masala</surname>
        </personname>
      </author>
    </authorgroup>
  </info>
  <para>
    <emphasis role="strong">Abstract</emphasis>
  </para>
  <section xml:id="introduction">
    <title>1. Introduction</title>
    <para>
      Mixnets are designed with the assumption that a Public Key
      Infrastructure (PKI) exists and it gives each client the same view
      of the network. This specification is inspired by the Tor and
      Mixminion Directory Authority systems
      <link linkend="MIXMINIONDIRAUTH">MIXMINIONDIRAUTH</link>
      <link linkend="TORDIRAUTH">TORDIRAUTH</link> whose main features
      are precisely what we need for our PKI. These are decentralized
      systems meant to be collectively operated by multiple entities.
    </para>
    <para>
      The mix network directory authority system (PKI) is essentially a
      cooperative decentralized database and voting system that is used
      to produce network consensus documents which mix clients
      periodically retrieve and use for their path selection algorithm
      when creating Sphinx packets. These network consensus documents
      are derived from a voting process between the Directory Authority
      servers.
    </para>
    <para>
      This design prevents mix clients from using only a partial view of
      the network for their path selection so as to avoid fingerprinting
      and bridging attacks
      <link linkend="FINGERPRINTING">FINGERPRINTING</link>,
      <link linkend="BRIDGING">BRIDGING</link>, and
      <link linkend="LOCALVIEW">LOCALVIEW</link>.
    </para>
    <para>
      The PKI is also used by Authority operators to specify
      network-wide parameters, for example in the Katzenpost Decryption
      Mix Network <link linkend="KATZMIXNET">KATZMIXNET</link> the
      Poisson mix strategy is used and, therefore, all clients must use
      the same lambda parameter for their exponential distribution
      function when choosing hop delays in the path selection. The Mix
      Network Directory Authority system, aka PKI, SHALL be used to
      distribute such network-wide parameters in the network consensus
      document that have an impact on security and performance.
    </para>
    <section xml:id="conventions-used-in-this-document">
      <title>1.1 Conventions Used in This Document</title>
      <para>
        The key words <quote>MUST</quote>, <quote>MUST NOT</quote>,
        <quote>REQUIRED</quote>, <quote>SHALL</quote>, <quote>SHALL
        NOT</quote>, <quote>SHOULD</quote>, <quote>SHOULD NOT</quote>,
        <quote>RECOMMENDED</quote>, <quote>MAY</quote>, and
        <quote>OPTIONAL</quote> in this document are to be interpreted
        as described in <link linkend="RFC2119">RFC2119</link>.
      </para>
      <para>
        The <quote>C</quote> style Presentation Language as described in
        <link linkend="RFC5246">RFC5246</link> Section 4 is used to
        represent data structures for additional cryptographic wire
        protocol commands.
        <link linkend="KATZMIXWIRE">KATZMIXWIRE</link>
      </para>
    </section>
    <section xml:id="terminology">
      <title>1.2 Terminology</title>
      <para>
        <literal>PKI</literal> - Public Key Infrastructure
      </para>
      <para>
        <literal>Directory Authority system</literal> - refers to
        specific PKI schemes used by
      </para>
      <para>
        Mixminion and Tor
      </para>
      <para>
        <literal>MSL</literal> - maximum segment lifetime
      </para>
      <para>
        <literal>mix descriptor</literal> - A database record which
        describes a component mix
      </para>
      <para>
        <literal>family</literal> - Identifier of security domains or
        entities operating one or more mixes in the network. This is
        used to inform the path selection algorithm.
      </para>
      <para>
        <literal>nickname</literal> - simply a nickname string that is
        unique in the consensus document, see <quote>Katzenpost Mix
        Network Specification</quote> section <quote>2.2. Network
        Topology</quote>.
      </para>
      <para>
        <literal>layer</literal> - The layer indicates which network
        topology layer a particular mix resides in.
      </para>
      <para>
        <literal>Provider</literal> - A service operated by a third
        party that Clients communicate directly with to communicate with
        the Mixnet. It is responsible for Client authentication,
        forwarding outgoing messages to the Mixnet, and storing incoming
        messages for the Client. The Provider MUST have the ability to
        perform cryptographic operations on the relayed messages.
      </para>
    </section>
    <section xml:id="security-properties-overview">
      <title>1.3 Security Properties Overview</title>
      <para>
        This Directory Authority system has the following feature goals
        and security properties:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            All Directory Authority servers must agree with each other
            on the set of Directory Authorities.
          </para>
        </listitem>
        <listitem>
          <para>
            All Directory Authority servers must agree with each other
            on the set of mixes.
          </para>
        </listitem>
        <listitem>
          <para>
            This system is intentionally designed to provide identical
            network consensus documents to each mix client. This
            mitigates epistemic attacks against the client path
            selection algorithm such as fingerprinting and bridge
            attacks <link linkend="FINGERPRINTING">FINGERPRINTING</link>
            <link linkend="BRIDGING">BRIDGING</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            This system is NOT byzantine-fault-tolerant, it instead
            allows for manual intervention upon consensus fault by the
            Directory Authority operators. Further, these operators are
            responsible for expelling bad acting operators from the
            system.
          </para>
        </listitem>
        <listitem>
          <para>
            This system enforces the network policies such as mix join
            policy wherein intentionally closed mixnets will prevent
            arbitrary hosts from joining the network by authenticating
            all descriptor signatures with a list of allowed public
            keys.
          </para>
        </listitem>
        <listitem>
          <para>
            The Directory Authority system for a given mix network is
            essentially the root of all authority.
          </para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section xml:id="differences-from-tor-and-mixminion-directory-authority-systems">
    <title>1.4 Differences from Tor and Mixminion Directory Authority
    systems</title>
    <para>
      In this document we specify a Directory Authority system which is
      different from that of Tor's and Mixminion’s in a number of ways:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          The list of valid mixes is expressed in an allowlist. For the
          time being there is no specified <quote>bandwidth
          authority</quote> system which verifies the health of mixes
          (Further research required in this area).
        </para>
      </listitem>
      <listitem>
        <para>
          There’s no non-directory channel to inform clients that a node
          is down, so it will end up being a lot of packet loss, since
          clients will continue to include the missing node in their
          path selection until keys published by the node expire and it
          falls out of the consensus.
        </para>
      </listitem>
      <listitem>
        <para>
          The schema of the mix descriptors is different from that used
          in Mixminion and Tor, including a change which allows our mix
          descriptor to express <emphasis>n</emphasis> Sphinx mix
          routing public keys in a single mix descriptor whereas in the
          Tor and Mixminion Directory Authority systems,
          <emphasis>n</emphasis> descriptors are used.
        </para>
      </listitem>
      <listitem>
        <para>
          The serialization format of mix descriptors is different from
          that used in Mixminion and Tor.
        </para>
      </listitem>
      <listitem>
        <para>
          The shared random number computation is performed every voting
          round, and is required for a vote to be accepted by each
          authority. The shared random number is used to
          deterministically generate the network topology.
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="overview-of-mix-pki-interaction">
    <title>2. Overview of Mix PKI Interaction</title>
    <para>
      Each Mix MUST rotate the key pair used for Sphinx packet
      processing periodically for forward secrecy reasons and to keep
      the list of seen packet tags short.
      <link linkend="SPHINX09">SPHINX09</link>
      <link linkend="SPHINXSPEC">SPHINXSPEC</link> The Katzenpost Mix
      Network uses a fixed interval (<literal>epoch</literal>), so that
      key rotations happen simultaneously throughout the network, at
      predictable times.
    </para>
    <para>
      Each Directory Authority server MUST use some time synchronization
      protocol in order to correctly use this protocol. This Directory
      Authority system requires time synchronization to within a few
      minutes.
    </para>
    <para>
      Let each epoch be exactly
      <literal>1200 seconds (20 minutes)</literal> in duration, and the
      0th Epoch begin at <literal>2017-06-01 00:00 UTC</literal>.
    </para>
    <para>
      To facilitate smooth operation of the network and to allow for
      delays that span across epoch boundaries, Mixes MUST publish keys
      to the PKI for at least 3 epochs in advance, unless the mix will
      be otherwise unavailable in the near future due to planned
      downtime.
    </para>
    <para>
      At an epoch boundary, messages encrypted to keys from the previous
      epoch are accepted for a grace period of 2 minutes.
    </para>
    <para>
      Thus, at any time, keys for all Mixes for the Nth through N + 2nd
      epoch will be available, allowing for a maximum round trip
      (forward message + SURB) delay + transit time of 40 minutes. SURB
      lifetime is limited to a single epoch because of the key rotation
      epoch, however this shouldn’t present any useability problems
      since SURBs are only used for sending ACK messages from the
      destination Provider to the sender as described in
      <link linkend="KATZMIXE2E">KATZMIXE2E</link>.
    </para>
    <section xml:id="pki-protocol-schedule">
      <title>2.1 PKI Protocol Schedule</title>
      <para>
        There are two main constraints to Authority schedule:
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            There MUST be enough key material extending into the future
            so that clients are able to construct Sphinx packets with a
            forward and reply paths.
          </para>
        </listitem>
        <listitem>
          <para>
            All participants should have enough time to participate in
            the protocol; upload descriptors, vote, generate documents,
            download documents, establish connections for user traffic.
          </para>
        </listitem>
      </orderedlist>
      <para>
        The epoch duration of 20 minutes is more than adequate for these
        two constraints.
      </para>
      <para>
        <emphasis>NOTE: perhaps we should make it shorter? but first
        let’s do some scaling and bandwidth calculations to see how bad
        it gets…</emphasis>
      </para>
    </section>
    <section xml:id="directory-authority-server-schedule">
      <title>2.1.1 Directory Authority Server Schedule</title>
      <para>
        Directory Authority server interactions are conducted according
        to the following schedule, where <literal>T</literal> is the
        beginning of the current epoch, and <literal>P</literal> is the
        length of the epoch period.
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>T</literal> - Epoch begins
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>T + P/2</literal> - Vote exchange
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>T + (5/8)*P</literal> - Reveal exchange
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>T + (6/8)*P</literal> - Tabulation and signature
            exchange
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>T + (7/8)*P</literal> - Publish consensus
          </para>
        </listitem>
      </itemizedlist>
    </section>
    <section xml:id="mix-schedule">
      <title>2.1.2 Mix Schedule</title>
      <para>
        Mix PKI interactions are conducted according to the following
        schedule, where T is the beginning of the current epoch.
      </para>
      <para>
        <literal>T + P/8</literal> - Deadline for publication of all
        mixes documents for the next epoch.
      </para>
      <para>
        <literal>T + (7/8)*P</literal> - This marks the beginning of the
        period where mixes perform staggered fetches of the PKI
        consensus document.
      </para>
      <para>
        <literal>T + (8/9)*P</literal> - Start establishing connections
        to the new set of relevant mixes in advance of the next epoch.
      </para>
      <para>
        <literal>T + P - 1MSL</literal> - Start accepting new Sphinx
        packets encrypted to the next epoch’s keys.
      </para>
      <para>
        <literal>T + P + 1MSL</literal> - Stop accepting new Sphinx
        packets encrypted to the previous epoch’s keys, close
        connections to peers no longer listed in the PKI documents and
        erase the list of seen packet tags.
      </para>
      <para>
        Mix layer changes are controlled by the Directory Authorities
        and therefore a mix can be reassigned to a different layer in
        our stratified topology at any new epoch. Mixes will maintain
        incoming and outgoing connections to the various nodes until all
        mix keys have expired, iff the node is still listed anywhere in
        the current document.
      </para>
    </section>
  </section>
  <section xml:id="voting-for-consensus-protocol">
    <title>3. Voting for Consensus Protocol</title>
    <para>
      In our Directory Authority protocol, all the actors conduct their
      behavior according to a common schedule as outlined in section
      &quot;2.1 PKI Protocol Schedule&quot;. The Directory Authority
      servers exchange messages to reach consensus about the network.
      Other tasks they perform include collecting mix descriptor uploads
      from each mix for each key rotation epoch, voting, shared random
      number generation, signature exchange and publishing of the
      network consensus documents.
    </para>
    <section xml:id="protocol-messages">
      <title>3.1 Protocol Messages</title>
      <para>
        There are only two document types in this protocol:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>mix_descriptor</literal>: A mix descriptor
            describes a mix.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>directory</literal>: A directory contains a list of
            descriptors and other information that describe the mix
            network.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Mix descriptor and directory documents MUST be properly signed.
      </para>
    </section>
    <section xml:id="mix-descriptor-and-directory-signing">
      <title>3.1.1 Mix Descriptor and Directory Signing</title>
      <para>
        Mixes MUST compose mix descriptors which are signed using their
        private identity key, an ed25519 key. Directories are signed by
        one or more Directory Authority servers using their authority
        key, also an ed25519 key. In all cases, signing is done using
        JWS <link linkend="RFC7515">RFC7515</link>.
      </para>
    </section>
    <section xml:id="vote-exchange">
      <title>3.2 Vote Exchange</title>
      <para>
        As described in section <quote>2.1 PKI Protocol
        Schedule</quote>, the Directory Authority servers begin the
        voting process 1/8 of an epoch period after the start of a new
        epoch. Each Authority exchanges vote directory messages with
        each other.
      </para>
      <para>
        Authorities archive votes from other authorities and make them
        available for retreival. Upon receiving a new vote, the
        authority examines it for new descriptors and includes any valid
        descriptors in its view of the network.
      </para>
      <para>
        Each Authority includes in its vote a hashed value committing to
        a choice of a random number for the vote. See section 4.3 for
        more details.
      </para>
      <para>
        <emphasis role="strong">3.2.1 Voting Wire Protocol
        Commands</emphasis>
      </para>
      <para>
        The Katzenpost Wire Protocol as described in
        <literal>KATZMIXWIRE</literal> is used by Authorities to
        exchange votes. We define additional wire protocol commands for
        sending votes:
      </para>
      <programlisting>
enum {

:   vote(22), vote_status(23),

} Command;
</programlisting>
      <para>
        The structures of these commands are defined as follows:
      </para>
      <programlisting>
struct {
:   uint64_t epoch_number; opaque public_key[ED25519_KEY_LENGTH];
    opaque payload[];

} VoteCommand;

struct {
:   uint8 error_code;

} VoteStatusCommand;
</programlisting>
      <para>
        <emphasis role="strong">3.2.2 The vote Command</emphasis>
      </para>
      <para>
        The vote command is used to send a PKI document to a peer
        Authority during the voting period of the PKI schedule.
      </para>
      <para>
        The payload field contains the signed and serialized PKI
        document representing the sending Authority’s vote. The
        public_key field contains the public identity key of the sending
        Authority which the receiving Authority can use to verify the
        signature of the payload. The epoch_number field is used by the
        receiving party to quickly check the epoch for the vote before
        deserializing the payload.
      </para>
      <para>
        Each authority MUST include its commit value for the shared
        random computation in this phase along with its signed vote.
        This computation is derived from the Tor Shared Random
        Subsystem, <link linkend="TORSRV">TORSRV</link>.
      </para>
      <para>
        <emphasis role="strong">3.2.3 The vote_status Command</emphasis>
      </para>
      <para>
        The vote_status command is used to reply to a vote command. The
        error_code field indicates if there was a failure in the
        receiving of the PKI document.
      </para>
      <programlisting>
enum {

:   vote_ok(0), /\* None error condition. */ vote_too_early(1), /*
    The Authority should try again later. */ vote_too_late(2), /*
    This round of voting was missed. \*/
}
</programlisting>
      <para>
        The epoch_number field of the vote struct is compared with the
        epoch that is currently being voted on. vote_too_early and
        vote_too_late are replied back to the voter to report that their
        vote was not accepted.
      </para>
    </section>
    <section xml:id="reveal-exchange">
      <title>3.3 Reveal Exchange</title>
      <para>
        As described in section <quote>2.1 PKI Protocol
        Schedule</quote>, the Directory Authority servers exchange the
        reveal values after they have exchanged votes which contain a
        commit value. Each Authority exchanges reveal messages with each
        other.
      </para>
      <para>
        3.3.1 Reveal Wire Protocol Commands
      </para>
      <para>
        The Katzenpost Wire Protocol as described in
        <link linkend="KATZMIXWIRE">KATZMIXWIRE</link> is used by
        Authorities to exchange reveal values previously commited to in
        their votes. We define additional wire protocol commands for
        exchanging reveals:
      </para>
      <programlisting>
enum {
:   reveal(25), reveal_status(26),
} Command;
</programlisting>
      <para>
        The structures of these commands are defined as follows:
      </para>
      <programlisting>
struct {
:   uint64_t epoch_number; opaque public_key[ED25519_KEY_LENGTH];
    opaque payload[];

} RevealCommand;

struct {
:   uint8 error_code;

} RevealStatusCommand;
</programlisting>
      <para>
        <emphasis role="strong">3.3.2 The reveal Command</emphasis>
      </para>
      <para>
        The reveal command is used to send a reveal value to a peer
        authority during the reveal period of the PKI schedule.
      </para>
      <para>
        The payload field contains the signed and serialized reveal
        value. The public_key field contains the public identity key of
        the sending Authority which the receiving Authority can use to
        verify the signature of the payload. The epoch_number field is
        used by the receiving party to quickly check the epoch for the
        reveal before deserializing the payload.
      </para>
      <para>
        <emphasis role="strong">3.3.3 The reveal_status
        Command</emphasis>
      </para>
      <para>
        The reveal_status command is used to reply to a reveal command.
        The error_code field indicates if there was a failure in the
        receiving of the shared random reveal value.
      </para>
      <programlisting>
enum {

:   reveal_ok(8), /* None error condition. */ reveal_too_early(9), 
    /* The Authority should try again later. */
    reveal_not_authorized(10), /* The Authority was rejected. */
    reveal_already_received(11), /* The Authority has already revealed
    this round. */ reveal_too_late(12) /* This round of revealing was
    missed. */

} Errorcodes;
</programlisting>
      <para>
        The epoch_number field of the reveal struct is compared with the
        epoch that is currently being voted on. reveal_too_early and
        reveal_too_late are replied back to the authority to report
        their reveal was not accepted. The status code
        reveal_not_authorized is used if the Authority is rejected. The
        reveal_already_received is used to report that a valid reveal
        command was already received for this round.
      </para>
    </section>
    <section xml:id="cert-exchange">
      <title>3.4 Cert Exchange</title>
      <para>
        The Cert command is the same as a Vote but contains the set of
        Reveal values as seen by the voting peer. In order to ensure
        that a misconfigured or malicious Authority operator cannot
        amplify their ability to influence the threshold voting process,
        after Reveal messages have been exchanged, Authorities vote
        again, including the Reveals seen by them. Authorities may not
        introduce new MixDescriptors at this phase in the protocol.
      </para>
      <para>
        Otherwise, a consensus partition can be obtained by witholding
        Reveal values from a threshold number of Peers. In the case of
        an even-number of Authorities, a denial of service by a single
        Authority was observed.
      </para>
    </section>
    <section xml:id="vote-tabulation-for-consensus-computation">
      <title>3.5 Vote Tabulation for Consensus Computation</title>
      <para>
        The main design constraint of the vote tabulation algorithm is
        that it MUST be a deterministic process that produces the same
        result for each directory authority server. This result is known
        as a network consensus file.
      </para>
      <para>
        A network consensus file is a well formed directory struct where
        the <literal>status</literal> field is set to
        <literal>consensus</literal> and contains 0 or more descriptors,
        the mix directory is signed by 0 or more directory authority
        servers. If signed by the full voting group then this is called
        a fully signed consensus.
      </para>
      <orderedlist numeration="arabic" spacing="compact">
        <listitem>
          <para>
            Validate each vote directory:
          </para>
        </listitem>
      </orderedlist>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            that the liveness fields correspond to the following epoch
          </para>
        </listitem>
        <listitem>
          <para>
            status is <literal>vote</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            version number matches ours
          </para>
        </listitem>
      </itemizedlist>
      <orderedlist numeration="arabic" spacing="compact">
        <listitem override="2">
          <para>
            Compute a consensus directory:
          </para>
        </listitem>
      </orderedlist>
      <para>
        Here we include a modified section from the Mixminion PKI spec
        <link linkend="MIXMINIONDIRAUTH">MIXMINIONDIRAUTH</link>:
      </para>
      <para>
        For each distinct mix identity in any vote directory:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            If there are multiple nicknames for a given identity, do not
            include any descriptors for that identity.
          </para>
        </listitem>
        <listitem>
          <para>
            If half or fewer of the votes include the identity, do not
            include any descriptors for the identity. <emphasis>This
            also guarantees that there will be only one identity per
            nickname.</emphasis>
          </para>
        </listitem>
        <listitem>
          <para>
            If we are including the identity, then for each distinct
            descriptor that appears in any vote directory:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                Do not include the descriptor if it will have expired on
                the date the directory will be published.
              </para>
            </listitem>
            <listitem>
              <para>
                Do not include the descriptor if it is superseded by
                other descriptors for this identity.
              </para>
            </listitem>
            <listitem>
              <para>
                Do not include the descriptor if it not valid in the
                next epoch.
              </para>
            </listitem>
            <listitem>
              <para>
                Otherwise, include the descriptor.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            Sort the list of descriptors by the signature field so that
            creation of the consensus is reproducible.
          </para>
        </listitem>
        <listitem>
          <para>
            Set directory <literal>status</literal> field to
            <literal>consensus</literal>.
          </para>
        </listitem>
      </itemizedlist>
      <orderedlist numeration="arabic">
        <listitem override="3">
          <para>
            Compute a shared random number from the values revealed in
            the <quote>Reveal</quote> step. Authorities whose reveal
            value does not verify their commit value MUST be excluded
            from the consensus round. Authorities ensure that their
            peers MUST participate in Commit-and-Reveal, and MUST use
            correct Reveal values obtained from other Peers as part of
            the <quote>Cert</quote> exchange.
          </para>
        </listitem>
        <listitem>
          <para>
            Generate or update the network topology using the shared
            random number as a seed to a deterministic random number
            generator that determines the order that new mixes are
            placed into the topology.
          </para>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section xml:id="signature-collection">
    <title>3.6 Signature Collection</title>
    <blockquote>
      <para>
        Each Authority signs their view of consensus, and exchanges
        detached Signatures with each other. Upon receiving each
        Signature it is added to the signatures on the Consensus if it
        validates the Consensus. The Authority SHOULD warn the
        administrator if network partition is detected.
      </para>
      <para>
        If there is disagreement about the consensus directory, each
        authority collects signatures from only the servers which it
        agrees with about the final consensus.
      </para>
      <para>
        // TODO: consider exchanging peers votes amongst authorities (or
        hashes thereof) to // ensure that an authority has distributed
        one and only unique vote amongst its peers.
      </para>
    </blockquote>
  </section>
  <section xml:id="publication">
    <title>3.7 Publication</title>
    <blockquote>
      <para>
        If the consensus is signed by a majority of members of the
        voting group then it's a valid consensus and it is published.
      </para>
    </blockquote>
  </section>
  <section xml:id="pki-protocol-data-structures">
    <title>4. PKI Protocol Data Structures</title>
    <section xml:id="mix-descriptor-format">
      <title>4.1 Mix Descriptor Format</title>
      <blockquote>
        <para>
          Note that there is no signature field. This is because mix
          descriptors are serialized and signed using JWS. The
          <literal>IdentityKey</literal> field is a public ed25519 key.
          The <literal>MixKeys</literal> field is a map from epoch to
          public X25519 keys which is what the Sphinx packet format
          uses.
        </para>
      </blockquote>
      <note>
        <title>Note</title>
        <para>
          XXX David: replace the following example with a JWS example:
        </para>
      </note>
      <programlisting>
{
    &quot;Version&quot;: 0,
    &quot;Name&quot;: &quot;&quot;,
    &quot;Family&quot;: &quot;&quot;,
    &quot;Email&quot;: &quot;&quot;,
    &quot;AltContactInfo&quot;:&quot;&quot;,
    &quot;IdentityKey&quot;: &quot;&quot;,
    &quot;LinkKey&quot;:&quot;&quot;,
    &quot;MixKeys&quot;: {
       &quot;Epoch&quot;: &quot;EpochPubKey&quot;,
    },
    &quot;Addresses&quot;: [&quot;IP:Port&quot;],
    &quot;Layer&quot;: 0,
    &quot;LoadWeight&quot;:0,
    &quot;AuthenticationType&quot;:&quot;&quot;
}
</programlisting>
    </section>
    <section xml:id="scheduling-mix-downtime">
      <title>4.1.1 Scheduling Mix Downtime</title>
      <blockquote>
        <para>
          Mix operators can publish a half empty mix descriptor for
          future epochs to schedule downtime. The mix descriptor fields
          that MUST be populated are:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              Version
            </para>
          </listitem>
          <listitem>
            <para>
              Name
            </para>
          </listitem>
          <listitem>
            <para>
              Family
            </para>
          </listitem>
          <listitem>
            <para>
              Email
            </para>
          </listitem>
          <listitem>
            <para>
              Layer
            </para>
          </listitem>
          <listitem>
            <para>
              IdentityKey
            </para>
          </listitem>
          <listitem>
            <para>
              MixKeys
            </para>
          </listitem>
        </itemizedlist>
        <para>
          The map in the field called &quot;MixKeys&quot; should reflect
          the scheduled downtime for one or more epochs by not have
          those epochs as keys in the map.
        </para>
      </blockquote>
    </section>
    <section xml:id="directory-format">
      <title>4.2 Directory Format</title>
      <para>
        <emphasis>Note: replace the following example with a JWS
        example</emphasis>
      </para>
      <programlisting>
{
    &quot;Signatures&quot;: [],
    &quot;Version&quot;: 0,
    &quot;Status&quot;: &quot;vote&quot;,
    &quot;Lambda&quot; : 0.274,
    &quot;MaxDelay&quot; : 30,
    &quot;Topology&quot; : [],
    &quot;Providers&quot; : [],
}
</programlisting>
    </section>
    <section xml:id="shared-random-value-structure">
      <title>4.3 Shared Random Value structure</title>
      <para>
        Katzenpost’s Shared Random Value computation is inspired by
        Tor’s Shared Random Subsystem
        <link linkend="TORSRV">TORSRV</link>.
      </para>
      <para>
        Each voting round a commit value is included in the votes sent
        to other authorities. These are produced as follows:
      </para>
      <programlisting>
H = blake2b-256

COMMIT = Uint64(epoch) | H(REVEAL) REVEAL = Uint64(epoch) | H(RN)
</programlisting>
      <para>
        After the votes are collected from the voting round, and before
        signature exchange, the Shared Random Value field of the
        consensus document is the output of H over the input string
        calculated as follows:
      </para>
      <orderedlist numeration="arabic" spacing="compact">
        <listitem>
          <para>
            Validated Reveal commands received including the authorities
            own reveal are sorted by reveal value in ascending order and
            appended to the input in format IdentityPublicKeyBytes_n |
            RevealValue_n
          </para>
        </listitem>
      </orderedlist>
      <para>
        However instead of the Identity Public Key bytes we instead
        encode the Reveal with the blake2b 256 bit hash of the public
        key bytes.
      </para>
      <orderedlist numeration="arabic" spacing="compact">
        <listitem override="2">
          <para>
            If a SharedRandomValue for the previous epoch exists, it is
            appended to the input string, otherwise 32 NUL (x00) bytes
            are used.
          </para>
        </listitem>
      </orderedlist>
      <programlisting>
REVEALS = ID_a \| R_a \| ID_b \| R_b \| \... SharedRandomValue =
H(&quot;shared-random&quot; | Uint64(epoch) | REVEALS | PREVIOUS_SRV)
</programlisting>
    </section>
    <section xml:id="pki-wire-protocol">
      <title>5. PKI Wire Protocol</title>
      <para>
        The Katzenpost Wire Protocol as described in
        <link linkend="KATZMIXWIRE">KATZMIXWIRE</link> is used by both
        clients and by Directory Authority peers. In the following
        section we describe additional wire protocol commands for
        publishing mix descriptors, voting and consensus retrieval.
      </para>
      <section xml:id="mix-descriptor-publication">
        <title>5.1 Mix Descriptor publication</title>
        <para>
          The following commands are used for publishing mix descriptors
          and setting mix descriptor status:
        </para>
        <programlisting>
enum {
      /* Extending the wire protocol Commands. */
      post_descriptor(20),
      post_descriptor_status(21),
}
</programlisting>
        <para>
          The structures of these command are defined as follows:
        </para>
        <programlisting>
struct {
   uint64_t epoch_number;
   opaque payload[];
} PostDescriptor;

struct {
   uint8 error_code;
} PostDescriptorStatus;
</programlisting>
      </section>
      <section xml:id="the-post_descriptor-command">
        <title>5.1.1 The post_descriptor Command</title>
        <para>
          The post_descriptor command allows mixes to publish their
          descriptors.
        </para>
      </section>
    </section>
    <section xml:id="the-post_descriptor_status-command">
      <title>5.1.2 The post_descriptor_status Command</title>
      <para>
        The post_descriptor_status command is sent in response to a
        post_descriptor command, and uses the following error codes:
      </para>
      <programlisting>
enum {
   descriptor_ok(0),
   descriptor_invalid(1),
   descriptor_conflict(2),
   descriptor_forbidden(3),
} ErrorCodes;
</programlisting>
    </section>
    <section xml:id="voting">
      <title>5.2 Voting</title>
      <para>
        The following commands are used by Authorities to exchange
        votes:
      </para>
      <programlisting>
enum {
   vote(22),
   vote_status(23),
   get_vote(24),
} Command;
</programlisting>
      <para>
        The structures of these commands are defined as follows:
      </para>
      <programlisting>
struct {
    uint64_t epoch_number;
    opaque public_key[ED25519_KEY_LENGTH];
    opaque payload[];
} VoteCommand;

struct {
   uint8 error_code;
} VoteStatusCommand;
</programlisting>
      <section xml:id="the-vote-command">
        <title>5.2.1 The vote Command</title>
        <para>
          The <literal>vote</literal> command is used to send a PKI
          document to a peer Authority during the voting period of the
          PKI schedule.
        </para>
        <para>
          The payload field contains the signed and serialized PKI
          document representing the sending Authority’s vote. The
          public_key field contains the public identity key of the
          sending Authority which the receiving Authority can use to
          verify the signature of the payload. The epoch_number field is
          used by the receiving party to quickly check the epoch for the
          vote before deserializing the payload.
        </para>
      </section>
      <section xml:id="the-vote_status-command">
        <title>5.2.2 The vote_status Command</title>
        <para>
          The <literal>vote_status</literal> command is used to reply to
          a vote command. The error_code field indicates if there was a
          failure in the receiving of the PKI document.
        </para>
        <programlisting>
enum {
   vote_ok(0),               /* None error condition. */
   vote_too_early(1),        /* The Authority should try again later. */
   vote_too_late(2),         /* This round of voting was missed. */
   vote_not_authorized(3),   /* The voter's key is not authorized. */
   vote_not_signed(4),       /* The vote signature verification failed */
   vote_malformed(5),        /* The vote payload was invalid */
   vote_already_received(6), /* The vote was already received */
   vote_not_found(7),        /* The vote was not found */
}
</programlisting>
        <para>
          The epoch_number field of the vote struct is compared with the
          epoch that is currently being voted on. vote_too_early and
          vote_too_late are replied back to the voter to report that
          their vote was not accepted.
        </para>
      </section>
      <section xml:id="the-get_vote-command">
        <title>5.2.3 The get_vote Command</title>
        <para>
          The <literal>get_vote</literal> command is used to request a
          PKI document (vote) from a peer Authority. The epoch field
          contains the epoch from which to request the vote, and the
          public_key field contains the public identity key of the
          Authority of the requested vote. A successful query is
          responded to with a vote command, and queries that fail are
          responded to with a vote_status command with error_code
          vote_not_found(7).
        </para>
      </section>
      <section xml:id="retrieval-of-consensus">
        <title>5.3 Retrieval of Consensus</title>
        <para>
          Providers in the Katzenpost mix network system
          <link linkend="KATZMIXNET">KATZMIXNET</link> may cache
          validated network consensus files and serve them to clients
          over the mix network's link layer wire protocol
          <link linkend="KATZMIXWIRE">KATZMIXWIRE</link>. We define
          additional wire protocol commands for requesting and sending
          PKI consensus documents:
        </para>
        <programlisting>
enum {
   /* Extending the wire protocol Commands. */
   get_consensus(18),
   consensus(19),
} Command;

The structures of these commands are defined as follows:
</programlisting>
        <programlisting>
struct {
    uint64_t epoch_number;
} GetConsensusCommand;

struct {
   uint8 error_code;
   opaque payload[];
} ConsensusCommand;
</programlisting>
      </section>
      <section xml:id="the-get_consensus-command">
        <title>5.3.1 The get_consensus Command</title>
        <para>
          The get_consensus command is a command that is used to
          retrieve a recent consensus document. If a given get_consensus
          command contains an Epoch value that is either too big or too
          small then a reply consensus command is sent with an empty
          payload. Otherwise if the consensus request is valid then a
          consensus command containing a recent consensus document is
          sent in reply.
        </para>
        <para>
          Initiators MUST terminate the session immediately upon
          reception of a get_consensus command.
        </para>
      </section>
      <section xml:id="the-consensus-command">
        <title>5.3.2 The consensus Command</title>
        <para>
          The consensus command is a command that is used to send a
          recent consensus document. The error_code field indicates if
          there was a failure in retrieval of the PKI consensus
          document.
        </para>
        <programlisting>
enum {
   consensus_ok(0),        /* None error condition and SHOULD be accompanied with
                              a valid consensus payload. */
   consensus_not_found(1), /* The client should try again later. */
   consensus_gone(2),      /* The consensus will not be available in the future. */
} ErrorCodes;
</programlisting>
      </section>
      <section xml:id="the-cert-command">
        <title>5.4.1 The Cert Command</title>
        <para>
          The <literal>cert</literal> command is used to send a PKI
          document to a peer Authority during the voting period of the
          PKI schedule. It is the same as the <literal>vote</literal>
          command, but must contain the set of SharedRandomCommit and
          SharedRandomReveal values as seen by the Authority during the
          voting process.
        </para>
      </section>
      <section xml:id="the-certstatus-command">
        <title>5.4.2 The CertStatus Command</title>
        <para>
          The <literal>cert_status</literal> command is the response to
          a <literal>cert</literal> command, and is the same as a
          <literal>vote_status</literal> response, other than the
          command identifier. Responses are CertOK, CertTooEarly,
          CertNotAuthorized, CertNotSigned, CertAlreadyReceived,
          CertTooLate
        </para>
      </section>
      <section xml:id="signature-exchange">
        <title>5.5 Signature Exchange</title>
        <para>
          Signatures exchange is the final round of the consensus
          protocol and consists of the Sig and SigStatus commands.
        </para>
      </section>
      <section xml:id="the-sig-command">
        <title>5.5.1 The Sig Command</title>
        <para>
          The <literal>sig</literal> command contains a detached
          Signature from PublicKey of Consensus for Epoch.
        </para>
      </section>
      <section xml:id="the-sigstatus-command">
        <title>5.5.2 The SigStatus Command</title>
        <para>
          The <literal>sig_status</literal> command is the response to a
          <literal>sig</literal> command. Responses are SigOK,
          SigNotAuthorized, SigNotSigned, SigTooEarly, SigTooLate,
          SigAlreadyReceived, and SigInvalid.
        </para>
      </section>
    </section>
    <section xml:id="scalability-considerations">
      <title>6. Scalability Considerations</title>
      <para>
        <emphasis>TODO: notes on scaling, bandwidth usage
        etc.</emphasis>
      </para>
    </section>
    <section xml:id="future-work">
      <title>7. Future Work</title>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            byzantine fault tolerance
          </para>
        </listitem>
        <listitem>
          <para>
            PQ crypto signatures for all PKI documents: mix descriptors
            and directories.
            <link linkend="SPHINCS256">SPHINCS256</link> could be used,
            we already have a golang implementation:
            https://github.com/Yawning/sphincs256/
          </para>
        </listitem>
        <listitem>
          <para>
            Make a Bandwidth Authority system to measure health of the
            network. Also perform load balancing as described in
            <link linkend="PEERFLOW">PEERFLOW</link>?
          </para>
        </listitem>
        <listitem>
          <para>
            Implement byzantine attack defenses as described in
            <link linkend="MIRANDA">MIRANDA</link> and
            <link linkend="MIXRELIABLE">MIXRELIABLE</link> where mix
            link performance proofs are recorded and used in a
            reputation system.
          </para>
        </listitem>
        <listitem>
          <para>
            Choose a different serialization/schema language?
          </para>
        </listitem>
        <listitem>
          <para>
            Use a append only merkle tree instead of this voting
            protocol.
          </para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section xml:id="anonymity-considerations">
    <title>8. Anonymity Considerations</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          This system is intentionally designed to provide identical
          network consensus documents to each mix client. This mitigates
          epistemic attacks against the client path selection algorithm
          such as fingerprinting and bridge attacks
          <link linkend="FINGERPRINTING">FINGERPRINTING</link>,
          <link linkend="BRIDGING">BRIDGING</link>.
        </para>
      </listitem>
      <listitem>
        <para>
          If consensus has failed and thus there is more than one
          consensus file, clients MUST NOT use this compromised
          consensus and refuse to run.
        </para>
      </listitem>
      <listitem>
        <para>
          We try to avoid randomizing the topology because doing so
          splits the anonymity sets on each mix into two. That is,
          packets belonging to the previous topology versus the current
          topology are trivially distinguishable. On the other hand if
          enough mixes fall out of consensus eventually the mixnet will
          need to be rebalanced to avoid an attacker compromised path
          selection. One example of this would be the case where the
          adversary controls the only mix is one layer of the network
          topology.
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="security-considerations">
    <title>9. Security Considerations</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          The Directory Authority / PKI system for a given mix network
          is essentially the root of all authority in the system. The
          PKI controls the contents of the network consensus documents
          that mix clients download and use to inform their path
          selection. Therefore if the PKI as a whole becomes compromised
          then so will the rest of the system in terms of providing the
          main security properties described as traffic analysis
          resistance. Therefore a decentralized voting protocol is used
          so that the system is more resiliant when attacked, in
          accordance with the principle of least authority.
          <link linkend="SECNOTSEP" role="citation">SECNOTSEP</link>
        </para>
      </listitem>
      <listitem>
        <para>
          Short epoch durations make it is more practical to make
          corrections to network state using the PKI voting rounds.
        </para>
      </listitem>
      <listitem>
        <para>
          Fewer epoch keys published in advance is a more conservative
          security policy because it implies reduced exposure to key
          compromise attacks.
        </para>
      </listitem>
      <listitem>
        <para>
          A bad acting Directory Authority who lies on each vote and
          votes inconsistently can trivially cause a denial of service
          for each voting round.
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section xml:id="acknowledgements">
    <title>10. Acknowledgements</title>
    <para>
      We would like to thank Nick Mathewson for answering design
      questions and thorough design review.
    </para>
  </section>
  <section xml:id="appendix-a.-references">
    <title>Appendix A. References</title>
    <section xml:id="appendix-a.1-normative-references">
      <title>Appendix A.1 Normative References</title>
      <para>
      </para>
    </section>
    <section xml:id="appendix-a.2-informative-references">
      <title>Appendix A.2 Informative References</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="appendix-b.-citing-this-document">
    <title>Appendix B. Citing This Document</title>
    <section xml:id="appendix-b.1-bibtex-entry">
      <title>Appendix B.1 Bibtex Entry</title>
      <para>
        Note that the following bibtex entry is in the IEEEtran bibtex
        style as described in a document called <quote>How to Use the
        IEEEtran BIBTEX Style</quote>.
      </para>
      <programlisting>
    @online{KatzMixPKI,
    title = {Katzenpost Mix Network Public Key Infrastructure Specification},
    author = {Yawning Angel and Ania Piotrowska and David Stainton},
    url= {https://github.com/katzenpost/katzenpost/blob/main/docs/specs/pki.rst},
    year = {2017}
    }
</programlisting>
      <para>
        <emphasis role="strong">BRIDGING</emphasis>
      </para>
      <para>
        Danezis, G., Syverson, P., <quote>Bridging and Fingerprinting:
        Epistemic Attacks on Route Selection</quote>, In the Proceedings
        of PETS 2008, Leuven, Belgium, July 2008,
        https://www.freehaven.net/anonbib/cache/danezis-pet2008.pdf
      </para>
      <para>
        <emphasis role="strong">FINGERPRINTING</emphasis>
      </para>
      <para>
        Danezis, G., Clayton, R., <quote>Route Finger printing in
        Anonymous Communications</quote>,
        https://www.cl.cam.ac.uk/~rnc1/anonroute.pdf
      </para>
      <para>
        <emphasis role="strong">KATZMIXE2E</emphasis>
      </para>
      <para>
        Angel, Y., Danezis, G., Diaz, C., Piotrowska, A., Stainton, D.,
        <quote>Katzenpost Mix Network End-to-end Protocol
        Specification</quote>, July 2017,
        https://github.com/katzenpost/katzenpost/blob/main/docs/specs/old/end_to_end.md
      </para>
      <para>
        <emphasis role="strong">KATZMIXNET</emphasis>
      </para>
      <para>
        Angel, Y., Danezis, G., Diaz, C., Piotrowska, A., Stainton, D.,
        <quote>Katzenpost Mix Network Specification</quote>, June 2017,
        https://github.com/katzenpost/katzenpost/blob/main/docs/specs/mixnet.md
      </para>
      <para>
        <emphasis role="strong">KATZMIXWIRE</emphasis>
      </para>
      <para>
        Angel, Y. <quote>Katzenpost Mix Network Wire Protocol
        Specification</quote>, June 2017,
        https://github.com/katzenpost/katzenpost/blob/main/docs/specs/wire-protocol.md
      </para>
      <para>
        <emphasis role="strong">LOCALVIEW</emphasis>
      </para>
      <para>
        Gogolewski, M., Klonowski, M., Kutylowsky, M., <quote>Local View
        Attack on Anonymous Communication</quote>,
        https://www.freehaven.net/anonbib/cache/esorics05-Klonowski.pdf
      </para>
      <para>
        <emphasis role="strong">MIRANDA</emphasis>
      </para>
      <para>
        Leibowitz, H., Piotrowska, A., Danezis, G., Herzberg, A., 2017,
        <quote>No right to ramain silent: Isolating Malicious
        Mixes</quote> https://eprint.iacr.org/2017/1000.pdf
      </para>
      <para>
        <emphasis role="strong">MIXMINIONDIRAUTH</emphasis>
      </para>
      <para>
        Danezis, G., Dingledine, R., Mathewson, N., <quote>Type III
        (Mixminion) Mix Directory Specification</quote>, December 2005,
        https://www.mixminion.net/dir-spec.txt
      </para>
      <para>
        <emphasis role="strong">MIXRELIABLE</emphasis>
      </para>
      <para>
        Dingledine, R., Freedman, M., Hopwood, D., Molnar, D., 2001
        <quote>A Reputation System to Increase MIX-Net
        Reliability</quote>, In Information Hiding, 4th International
        Workshop https://www.freehaven.net/anonbib/cache/mix-acc.pdf
      </para>
      <para>
        <emphasis role="strong">PEERFLOW</emphasis>
      </para>
      <para>
        Johnson, A., Jansen, R., Segal, A., Syverson, P.,
        <quote>PeerFlow: Secure Load Balancing in Tor</quote>,
        Preceedings on Privacy Enhancing Technologies, July 2017,
        https://petsymposium.org/2017/papers/issue2/paper12-2017-2-source.pdf
      </para>
      <para>
        <emphasis role="strong">RFC2119</emphasis>
      </para>
      <para>
        Bradner, S., <quote>Key words for use in RFCs to Indicate
        Requirement Levels</quote>, BCP 14, RFC 2119, DOI
        10.17487/RFC2119, March 1997,
        https://www.rfc-editor.org/info/rfc2119
      </para>
      <para>
        <emphasis role="strong">RFC5246</emphasis>
      </para>
      <para>
        Dierks, T. and E. Rescorla, <quote>The Transport Layer Security
        (TLS) Protocol Version 1.2</quote>, RFC 5246, DOI
        10.17487/RFC5246, August 2008,
        http://www.rfc-editor.org/info/rfc5246
      </para>
      <para>
        <emphasis role="strong">RFC7515</emphasis>
      </para>
      <para>
        Jones, M., Bradley, J., Sakimura, N., <quote>JSON Web Signature
        (JWS)</quote>, May 2015, https://tools.ietf.org/html/rfc7515
      </para>
      <para>
        <emphasis role="strong">SECNOTSEP</emphasis>
      </para>
      <para>
        Miller, M., Tulloh, B., Shapiro, J., <quote>The Structure of
        Authority: Why Security Is not a Separable Concern</quote>,
        http://www.erights.org/talks/no-sep/secnotsep.pdf
      </para>
      <para>
        <emphasis role="strong">SPHINCS256</emphasis>
      </para>
      <para>
        Bernstein, D., Hopwood, D., Hulsing, A., Lange, T., Niederhagen,
        R., Papachristodoulou, L., Schwabe, P., Wilcox O’ Hearn, Z.,
        <quote>SPHINCS: practical stateless hash-based
        signatures</quote>, http://sphincs.cr.yp.to/sphincs-20141001.pdf
      </para>
      <para>
        <emphasis role="strong">SPHINX09</emphasis>
      </para>
      <para>
        Danezis, G., Goldberg, I., <quote>Sphinx: A Compact and Provably
        Secure Mix Format</quote>, DOI 10.1109/SP.2009.15, May 2009,
        http://research.microsoft.com/en-us/um/people/gdane/papers/sphinx-eprint.pdf
      </para>
      <para>
        <emphasis role="strong">SPHINXSPEC</emphasis>
      </para>
      <para>
        Angel, Y., Danezis, G., Diaz, C., Piotrowska, A., Stainton, D.,
        <quote>Sphinx Mix Network Cryptographic Packet Format
        Specification</quote> July 2017,
        https://github.com/katzenpost/katzenpost/blob/main/docs/specs/sphinx.md
      </para>
      <para>
        <emphasis role="strong">TORDIRAUTH</emphasis>
      </para>
      <para>
        <quote>Tor directory protocol, version 3</quote>,
        https://gitweb.torproject.org/torspec.git/tree/dir-spec.txt
      </para>
      <para>
        <emphasis role="strong">TORSRV</emphasis>
      </para>
      <para>
        <quote>Tor Shared Random Subsystem Specification</quote>,
        https://gitweb.torproject.org/torspec.git/tree/srv-spec.txt
      </para>
    </section>
  </section>
</article>
