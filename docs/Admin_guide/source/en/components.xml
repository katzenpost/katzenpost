<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.2/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.2/sch/docbook.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>

<!--A DOCTYPE declaration declaring a DTD is not need for DocBook 5.x, which uses RelaxNG and  Schematron instead. It is used here as a container for entity declarations.-->

<!DOCTYPE chapter 
[
    <!ENTITY % shared-content SYSTEM "shared-content.ent">
    %shared-content;
]>

<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.1" xml:id="components">
    <title xml:id="components.title">Components of the Katzenpost mixnet</title>
<!--    <para>Katzenpost can be used as a message oriented transport for a variety of applications and
        is in no way limited to the e-mail use case demonstrated by the mailproxy client/library.
        Other possible applications of Katzenpost include but are not limited to: instant messenger
        applications, crypto currency transaction transport, bulletin board systems, file sharing
        and so forth. </para>
    <para>• client (daemon) </para>
    <para>The client is a long running process that listen on a unix domain socket for connections
        from locally running applications on the same computer that want to use the mixnet so it's
        both a library and a unix daemon.</para>
    <para>
        <constraintdef>
            <para><emphasis role="bold">Client2 – can multiplex. Current client does not multiplex.
                    An adversary can observe processes and correlete. </emphasis></para>
            <para><emphasis role="bold">Other C2 feature is language integration capability – thin
                clients. Using a socket to connect directly to the daemon. Write a thin client,
                and then you no longer need to do stuff in Go. -\- This stuff could be written in
                couple of months, but could take a year yet.</emphasis></para>
        </constraintdef>
    </para>
    <para>Architecturally, the Katzenpost system has five component categories: <itemizedlist>
        <listitem>
            <para>Directory authorities</para>
        </listitem>
        <listitem>
            <para>Mix nodes</para>
        </listitem>
        <listitem>
            <para>Service nodes</para>
        </listitem>
        <listitem>
            <para>Gateway nodes</para>
            <para>the spool and user DBs are located on the Gateway nodes</para>
            <para>the services like Panda are located on the Service nodes</para>
            <para>when a user connects to the mixnet they only talk to a random Gateway
                node</para>
            <para>the Gateway node has to have the spool db... in order to receive messages for
                the users that are connected to it... those messages are responses to mixnet
                service queries which run on the service nodes.</para>
        </listitem>
        <listitem>
            <para>Clients</para>
        </listitem>
    </itemizedlist></para>
    <para>Functionally, Katzenpost presently supports several services.  All services use SURBs:<itemizedlist>
        <listitem>
            <para>Echo </para>
            <para>send sent payload back to you; uses the SURB sent in the ping</para>
        </listitem>
        <listitem>
            <para>Panda</para>
            <para>Reunion and Panda are our only ways of making key exchanges over the mixnet.
                both of those are Password Authenticated Key Exchange protocols which is a
                special categories of cryptographic protocols. In the past couple of years the
                Reunion implementation just stopped working... due to bitrot and not being
                maintained. So now all we have is Panda. \u0000</para>
        </listitem>
        <listitem>
            <para>Pigeonhole</para>
            <para>pigeonhole storage service – mailbox pigeonholes. Adeversaries don’t know what
                box has what messgae. Looks like messages are randomly scattered, but it is a
                computed permutation, deterministic. BACAP – defined in paper. Whether you can
                read or right off a box, based on blinded cryptographic signatures. Data is
                stored that has been sent across the mixnet. Not linakable to events. All new
                services will proably be buklt on pigeonhole. Paper authors oare inventors of
                pigeonhole. An existing off the sehld DB will be used to write to disk. PH will
                be the adressing stratey. REDIS, RockDB, or some other – can be anything.</para>
            <para>Designed for low latency -\-; not good for video, however. None of the protocls
                we build require bothparties to be online, though they can be. </para>
        </listitem>
    </itemizedlist></para>-->
    <!--
        
    AWS model for APIs:
    
    [Definition] 
    
    Type: String
    
    Length Constraints: Maximum length of 256.
    
    Pattern: ^[A-Za-z0-9+/=]+$
    
    Required: No
    
    -->
    <section xml:id="auth">
        <title xml:id="auth.title">Directory authorities</title>

		<para>The public key infrastructure (PKI) protocol for Katzenpost, also known
as the Directory Authority or dirauth, is a decentralized system of nodes
which vote for each epoch's consensus document. If we used a BFT protocol instead
then the dirauth system would fail when 1/3 + 1 nodes failed. Therefore we can
say that our crash fault tolerant system is more robust because it will fail
when 1/2 + 1 nodes fail.</para>
		<para>The Katzenpost PKI is the security root of the entire system because all clients
and network nodes will depend on the PKI to sign the consensus document for each epoch.
Currently epoch duration is every 20 minutes. The consensus document is essentially a view of
the network, it contains all the connection information and all the public cryptographic key materials
and signatures. Each mix node signs it's descriptor and uploads it to the dirauth nodes. Each dirauth
node signs the consensus. When clients or nodes download the consensus document they are able to verify
the dirauth node signatures on the document.</para>
		<para>The PKI signature scheme is fully configurable by the dir auth nodes. Currently our recommendation is to
use a hybrid signature scheme consisting of the classical Ed25519 and the
post quantum stateless hash based signature scheme known as Sphincs+ (with the parameters: `sphincs-shake-256f`); which is
designated in katzenpost configurations as "Ed25519 Sphincs+" which you can see examples of below.</para>        

        <section xml:id="auth-config">
            <title xml:id="auth-config.title">Configuring directory authorities</title>
            <para>The following configuration is drawn from the reference implementation in
                <filename>katzenpost/docker/voting_mixnet/auth1/authority.toml</filename>. In a
                real-world mixnet, the component hosts would not be sharing a single IP address. For
                more information about the test mixnet, see <link linkend="container"
                    endterm="container.title">Using the Katzenpost test network</link>.</para>
<!--General TOML note:

https://toml.io/en/v1.0.0

Array of Tables

The last syntax that has not yet been described allows writing arrays of tables. These can be expressed by using a header with a name in double brackets. The first instance of that header defines the array and its first table element, and each subsequent instance creates and defines a new table element in that array. The tables are inserted into the array in the order encountered.

So single brackets define a "table". Double brackets define an array of "tables". AND the initial double-bracket block serves as both an array definition and an element of the array it created. 

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                
https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/authority/voting/server/config/config.go#L475

// Config is the top level authority configuration.
type Config struct {
	Server      *Server
	Authorities []*Authority
	Logging     *Logging
	Parameters  *Parameters
	Debug       *Debug

	Mixes        []*Node
	GatewayNodes []*Node
	ServiceNodes []*Node
	Topology     *Topology

	SphinxGeometry *geo.Geometry
}
            
-->
            <section xml:id="auth-server-section-config">
                <title xml:id="auth-server-section-config.title">Server section</title>
                <!--https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/authority/voting/server/config/config.go#L415-->
                <para/>
                <programlisting>[Server]
    Identifier = "auth1"
    WireKEMScheme = "xwing"
    PKISignatureScheme = "Ed25519 Sphincs+"
    Addresses = ["tcp://127.0.0.1:30001"]
    DataDir = "/voting_mixnet/auth1"</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Identifier</emphasis></para>
                        <para>Identifier is the human readable identifier for the node which should be unique per mixnet. It can be an FQDN but certainly doesn't have to be.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">WireKEMScheme</emphasis></para>
                        <para>WireKEMScheme is the wire protocol KEM scheme to use. This is another configuration point where 
                        it's possible to use post quantum cryptography to strengthen security. In this case the "Wire" protocol 
                        refers to our PQ Noise based protocol which is how all the dir auth nodes talk to one another. PQ Noise is a 
                        variation of the Noise protocol framework where the handshake patterns are algebraically transformed to replace
						ECDH operations with KEM encapsulate/decapsulate operations.</para>
						<para>Here are all the KEM scheme names currently supported by Katzenpost:
							"x25519", "x448", "mlkem768", "sntrup4591761", "frodo640shake", "mceliece348864", "mceliece348864f",
							"mceliece460896", "mceliece460896f", "mceliece6688128", "mceliece6688128f", "mceliece6960119", "mceliece6960119f",
							"mceliece8192128", "mceliece8192128f", "xwing", "Kyber768-X25519", "MLKEM768-X25519", "MLKEM768-X448",
							"CTIDH511", "CTIDH512", "CTIDH1024", "CTIDH2048", "CTIDH512-X25519", "CTIDH512-X25519"
						</para>						
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">PKISignatureScheme</emphasis></para>
                        <para>PKISignatureScheme specifies the cryptographic signature scheme which will be used by all components of the mix network
                        when interacting with the PKI system. Mix nodes will sign their descriptors using this signature scheme. Likewise PKI documents
                        will be signed by the dir auth nodes using this signature scheme.</para>
                        <para>Here are all the signature scheme names currently supported by Katzenpost:
                        	"ed25519", "ed448", "Ed25519 Sphincs+", "Ed448-Sphincs+", "Ed25519-Dilithium2", "Ed448-Dilithium3"
                        	</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Addresses</emphasis></para>
                        <para>Addresses specifies a list of one or more Address URLs in a format that contains the transport protocol,
                        IP address and port number that the server will bind to for incoming connections.
                        Currently Katzenpost supports URLs with that start with either "tcp://" or "quic://" such as: ["tcp://192.168.1.1:30001"] and ["quic://192.168.1.1:40001"]
                        </para>
                        <para>Type: []string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">DataDir</emphasis></para>
                        <para>DataDir is the absolute path to the directory authority server's state directory where the persistence.db will be written to disk AND
                        where the server's cryptographic key materials will be written to disk when started with the "-g" commmandline option.</para>
                        <para>Type: string</para>
                    </listitem>
                </itemizedlist>
                <para/>
            </section>
            <section xml:id="auth-authorities-section-config">
                <title xml:id="auth-authorities-section-config.title">Authorities section</title>
                <!--https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/authority/voting/server/config/config.go#L266-->
                <para>An Authorities section is configured for each peer authority. We recommend using TOML's muli-line quotes for key materials.</para>
                <programlisting>[[Authorities]]
    Identifier = "auth1"
    IdentityPublicKey = """
-----BEGIN ED25519 PUBLIC KEY-----
dYpXpbozjFfqhR45ZC2q97SOOsXMANdHaEdXrP42CJk=
-----END ED25519 PUBLIC KEY-----
"""
    PKISignatureScheme = "Ed25519"
    LinkPublicKey = """
-----BEGIN XWING PUBLIC KEY-----
ooQBPYNdmfwnxXmvnljPA2mG5gWgurfHhbY87DMRY2tbMeZpinJ5BlSiIecprnmm
QqxcS9o36IS62SVMlOUkw+XEZGVvc9wJqHpgEgVJRAs1PCR8cUAdM6QIYLWt/lkf
SPKDCtZ3GiSIOzMuaglo2tarIPEv1AY7r9B0xXOgSKMkGyBkCfw1VBZf46MM26NL
opKx+rAKBzjKBJgGg9AHt9rNQsBbCVFBO+KKbpHHXFCBztK1Hhei3LeeYxcqL4bC
Rzi2kfBvQLPNzIuHOktKX7m39CxMByMNm4qL6dSVbtZaMOenpUlsIHOR5vyF2bgX
syRS3WnPRaIOarkMXUwJpzasNzuPUSAmJyaAQVwgrTSJyXp91usF6wBHKApqlDVY
dldqH7O90EI1tYNiOYpBCgwGBIK+xOkjoVNY91B/PVbA5ngcXgt8xQp02WXF1lVN
+ixu2XF8ndJXtLmlTIMUb0YwHsEo9UqdN7yLMPqcVScqR+ZKyCpaIPS+dpF20AAu
fvVVlxKVLqonUkJLCMgR/4morUOXVHwRgkKr0mIuw9RTWwSlSGxasFiVFZM5p6kS
ElIgPlCX94xV52BjcerPQ1R2TJdlVdWgLUAO7UNhyETCGrdxjxZSYmxNjfsOLHk7
qFNNDhUqHBjJmYOSDis0qHNXW8oZ9SF6pFN9NlctH8Uq10c/fNltykEbTkgLdMJP
phWWVQWD1YIU+/ktO5ZNVIVK/CHOqdc41+mRyxh/OmbEWMaaicuijLNR3KV9QoHG
9JWw9RtrPeE+jbgUX0g0asFf0nibfWqdV5QfAfwV/shYuIJR4nZMb6B4R9t8wYd0
gCSZg1M7gJW1J5B17cPM6+OCz2JaYhgAHfvJhSYK3zGzWWvGWvKTJrSTjiIhX8wM
H/KiX5U8+nkWPDiu/nqyRVej8/ELYvg7T2R7tKJzB0Gr5GUFd3B1TzvAcIRBl+yd
9ma5tRE44cu1yONuc1N8ITp8xqezSjwdavoMeuphryd6xbacZCVCcnM2R5mGOAhI
xzQWA5teHxoBTnliRQq1HriKX8N8Ogq3GPYu0Lue+MwEkkRkxSJdNpSLE/yzOQkf
DrlBbbURIfe1T6aeA1SuXeacTzqd6lfPWvjCgXMYriwhAazKwgS+WwcXd5RKbWEN
PIISgRavtoahEdOVSJJbVMUYptA3+CcY9eEi/rWOc1RgTWGNtWW0FYnFyiq6UdPM
NiO/z7S9uJJI/2wWMlJi+OoTx9cf3mjIMOPLkzEOhpVRhCZvcSvFIoF6ItcETnda
HmmOFwFg2reqlPioBORUufk7zdhs0MuuMYlaG+E0OqxTOKiZg0qbgMZqtOlsXkp8
QdY8R/W4ePiVAI2iZnMzEqMl3LLEDlRdMOkBYzOkR2GSvpYv6tetgoNAu8vFkpc6
Rma3y7KnihWaYhwEFbEqV2kD2GO9cMV+AcFvuCE9dVGVSatdxsSNX6ZXaFGlmHCp
gHtNyQJnXski52O03JpZRIhR40pFOhAAcMMAZDpMTVoxlcdR6WA4SlBiSceeJBgY
Yp9PlGhCimx9am99TrdLoLCdTHB6oowt8tss3POpIOxaSlguyeym/sBhkUrnXOgN
ldMtDsvvc9KUfE4I0+c+XQ==
-----END XWING PUBLIC KEY-----
    """
    WireKEMScheme = "xwing"
    Addresses = ["tcp://127.0.0.1:30001"]
</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Identifier</emphasis></para>
                        <para>Identifier is the human readable identifier for the node which should be unique per mixnet. It can be an FQDN but certainly doesn't have to be.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">IdentityPublicKey</emphasis></para>
                        <para>String in PEM format containing the public identity key. The node's public identity key is
                        the node's permanent identifier and is used to verify cryptographic signatures produce by node's private identity key.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">PKISignatureScheme</emphasis></para>
                        <para>PKISignatureScheme specifies the cryptographic signature scheme used by all of the directory authority nodes.
                        	  This PKISignatureScheme must match the scheme specified in the Server section of the configuration.
                        </para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LinkPublicKey</emphasis></para>
                        <para>LinkPublicKeyPem is string containing the PEM format of the peer's
                            public link layer key. The Katzenpost "link layer" protocol is the PQ Noise based protocol
                            which is sometimes also referred to as the "wire protocol". The type of this link public key
                            must match the specified WireKEMScheme. Our wire protocol is used to secure the transport
                            between nodes only and in this case it's used between directory authority nodes when they
                            communicate with each other for the voting rounds and it's also the protocol that clients
                            use to retrieve published PKI documents from the dir auth nodes.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">WireKEMScheme</emphasis></para>
                        <para>WireKEMScheme is the wire protocol KEM scheme to use. This is another configuration point where 
                        it's possible to use post quantum cryptography to strengthen security. In this case the "Wire" protocol 
                        refers to our PQ Noise based protocol which is how all the dir auth nodes talk to one another. PQ Noise is a 
                        variation of the Noise protocol framework where the handshake patterns are algebraically transformed to replace
						ECDH operations with KEM encapsulate/decapsulate operations.</para>
						<para>Here are all the KEM scheme names currently supported by Katzenpost:
							"x25519", "x448", "mlkem768", "sntrup4591761", "frodo640shake", "mceliece348864", "mceliece348864f",
							"mceliece460896", "mceliece460896f", "mceliece6688128", "mceliece6688128f", "mceliece6960119", "mceliece6960119f",
							"mceliece8192128", "mceliece8192128f", "xwing", "Kyber768-X25519", "MLKEM768-X25519", "MLKEM768-X448",
							"CTIDH511", "CTIDH512", "CTIDH1024", "CTIDH2048", "CTIDH512-X25519", "CTIDH512-X25519"
						</para>						
                        <para>Type: string</para>                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Addresses</emphasis></para>
                        <para>Addresses specifies a list of one or more Address URLs in a format that contains the transport protocol,
                        IP address and port number that the server will bind to for incoming connections.
                        Currently Katzenpost supports URLs with that start with either "tcp://" or "quic://" such as: ["tcp://192.168.1.1:30001"] and ["quic://192.168.1.1:40001"]
                        </para>
                        <para>Type: []string</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-logging">
                <title xml:id="auth-logging.title">Logging section</title>
                    &logging;
            </section>
            <section xml:id="auth-parameters">
                <title xml:id="auth-parameters.title">Parameters section</title>
                <!--https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/authority/voting/server/config/config.go#L103
-->
                <para>The Parameters section holds the network parameters, for example:</para>
                <programlisting>[Parameters]
    SendRatePerMinute = 0
    Mu = 0.005
    MuMaxDelay = 1000
    LambdaP = 0.001
    LambdaPMaxDelay = 1000
    LambdaL = 0.0005
    LambdaLMaxDelay = 1000
    LambdaD = 0.0005
    LambdaDMaxDelay = 3000
    LambdaM = 0.0005
    LambdaG = 0.0
    LambdaMMaxDelay = 100
    LambdaGMaxDelay = 100</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">SendRatePerMinute</emphasis></para>
                        <para>
                            SendRatePerMinute is the maximum allowed rate of packets per
                            client per gateway node. Rate limiting is done on the gateway nodes.</para>
                        <para>SendRatePerMinute is the rate per minute.</para>
                        <para>Type: uint64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Mu</emphasis></para>
                        <para>Mu is the inverse of the mean of the exponential distribution that the Sphinx
                            packet per-hop mixing delay will be sampled from.
                        	Mu is the inverse of the mean of the exponential
                            distribution that is used to select the delay for each hop.</para>
                        <para>Type: float64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">MuMaxDelay</emphasis></para>
                        <para>MuMaxDelay is the maximum Sphinx packet per-hop mixing delay in
                            milliseconds. MuMaxDelay sets the maximum delay for Mu.</para>
                        <para>Type:
                            uint64<?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?></para>
                    </listitem><?oxy_custom_end?>
                    <listitem>
                        <para><emphasis role="bold">LambdaP</emphasis></para>
                        <para>LambdaP is the inverse of the mean of the exponential distribution that
                            clients will sample to determine the time interval between sending
                            messages from it's FIFO egress queue or drop decoy messages if the queue
                            is empty. LambdaP is the inverse of the mean of the exponential
                            distribution that is used to select the delay between clients sending from
                            their egress FIFO queue or drop decoy message.</para>
                        <para>Type: float64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaPMaxDelay</emphasis></para>
                        <para>LambdaPMaxDelay is the maximum send interval for LambdaP in
                            milliseconds</para>
                        <para>LambdaPMaxDelay sets the maximum delay for LambdaP.</para>
                        <para>Type: uint64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaL</emphasis></para>
                        <para>LambdaL is the inverse of the mean of the exponential distribution
                            that is used to select the delay between clients sending loop
                            decoys.</para>
                        <para>Type: float64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaLMaxDelay</emphasis></para>
                        <para><?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>
                            sets the maximum send interval for LambdaL in milliseconds.</para>
                        <para><?oxy_custom_end?>LambdaLMaxDelay sets the maximum delay for
                            LambdaP.</para>
                        <?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>
                        <para><?oxy_custom_end?>Type: uint64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaD</emphasis></para>
                        <para>LambdaD is the inverse of the mean of the exponential distribution that clients
                            will sample to determine the time interval between sending decoy drop
                            messages. LambdaD is the inverse of the mean of the exponential
                            distribution that is used to select the delay between clients sending deop
                            decoys.</para>
                        <para>Type: float64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaDMaxDelay</emphasis></para>
                        <para>LambdaDMaxDelay is the maximum send interval in milliseconds.
                        LambdaDMaxDelay sets the maximum delay for LambdaP.</para>
                        <para>Type: uint64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaM</emphasis></para>
                        <para>LambdaM is the inverse of the mean of the exponential distribution that mixes will
                            sample to determine send timing of mix loop decoy
                            traffic. LambdaM is the inverse of the mean of the exponential
                            distribution that is used to select the delay between sending mix node
                            decoys.</para>
                        <para>Type: float64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaG</emphasis></para>
                        <para>LambdaG is the inverse of the mean of the exponential
                            distribution that is used to select the delay between sending gateway node
                            decoys. WARNING: DO NOT SET THIS VALUE. This is not used via the TOML config file; this field is
                            used internally by the dirauth server state machine.</para>
                        <para>Type: float64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaMMaxDelay</emphasis></para>
                        <para>LambdaMMaxDelay sets the maximum delay for LambdaM
                        LambdaMMaxDelay sets the maximum delay for LambdaP.</para>
                        <para>Type: uint64</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">LambdaGMaxDelay</emphasis></para>
                        <para>LambdaGMaxDelay sets the maximum delay for LambdaG.</para>
                        <para>Type: uint64</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-debug">
                <title xml:id="auth-debug.title">Debug section</title>
                <!--https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/authority/voting/server/config/config.go#L235-->
                <para/>
                <programlisting>[Debug]
    Layers = 3
    MinNodesPerLayer = 1
    GenerateOnly = false</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Layers</emphasis></para>
                        <para> Number of
                            <?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>non-provider<?oxy_custom_end?>
                            layers in the network topology.</para>
                        <para>Type: int</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">MinNodesrPerLayer</emphasis></para>
                        <para> Minimum number of nodes per layer required to form a valid
                            <?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>document<?oxy_custom_end?>.</para>
                        <para>Type: int</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">GenerateOnly</emphasis></para>
                        <para>If set to true, the server halts and cleans up the data directory
                            immediately after long-term key generation.</para>
                        <para>Type: bool</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-mixes-section-config">
                <title xml:id="auth-mixes-section-config.title">Mixes sections</title>
                <!--https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/authority/voting/server/config/config.go#L383-->
                <para><?oxy_comment_start author="dwrob" timestamp="20240814T111809-0700" comment="These definitions differ significantly from the code comments."?>The
                    Mixes configuration section lists mix nodes that are known to the
                    authority.</para><?oxy_comment_end?>
                <programlisting>[[Mixes]]
    Identifier = "mix1"
    IdentityPublicKeyPem = "../mix1/identity.public.pem"

[[Mixes]]
    Identifier = "mix2"
    IdentityPublicKeyPem = "../mix2/identity.public.pem"

[[Mixes]]
    Identifier = "mix3"
    IdentityPublicKeyPem = "../mix3/identity.public.pem"<?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?></programlisting><?oxy_custom_end?>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Identifier</emphasis></para>
                        <para>A human readable mix node identifier.</para>
                        <para>Type:
                            string<?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?></para>
                    </listitem><?oxy_custom_end?>
                    <listitem>
                        <para><emphasis role="bold">IdentityPublicKeyPem</emphasis></para>
                        <para>Path and file name of a mix node's public identity signing key, also
                            known as the identity key, in PEM format.</para>
                        <para>Type: string</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-gatewaynodes-section-config">
                <title xml:id="auth-gatewaynodes-section-config.title">GatewayNodes sections</title>
                <?oxy_comment_start author="dwrob" timestamp="20240814T111809-0700" comment="These definitions differ significantly from the code comments."?>
                <para>The GatewayNodes configuration section lists gateway nodes that are known to
                    the authority.</para><?oxy_comment_end?>
                <programlisting>[[GatewayNodes]]
    Identifier = "gateway1"
    IdentityPublicKeyPem = "../gateway1/identity.public.pem"</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Identifier</emphasis></para>
                        <para>A human readable gateway node identifier.</para>
                        <para>Type:
                            string<?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?></para>
                    </listitem><?oxy_custom_end?>
                    <listitem>
                        <para><emphasis role="bold">IdentityPublicKeyPem</emphasis></para>
                        <para>Path and file name of a gateway node's public identity signing key, also
                            known as the identity key, in PEM format.</para>
                        <para>Type: string</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-servicenodes-section-config">
                <title xml:id="auth-servicenodes-section-config.title">ServiceNodes sections</title>
                <?oxy_comment_start author="dwrob" timestamp="20240814T111809-0700" comment="These definitions differ significantly from the code comments."?>
                <para>The ServiceNodes configuration section lists service nodes that are known to
                    the authority.</para><?oxy_comment_end?>
                <programlisting>[[ServiceNodes]]
    Identifier = "servicenode1"
    IdentityPublicKeyPem = "../servicenode1/identity.public.pem"</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Identifier</emphasis></para>
                        <para>A human readable service node identifier.</para>
                        <para>Type:
                            string<?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?></para>
                    </listitem><?oxy_custom_end?>
                    <listitem>
                        <para><emphasis role="bold">IdentityPublicKeyPem</emphasis></para>
                        <para>Path and file name of a service node's public identity signing key, also
                            known as the identity key, in PEM format.</para>
                        <para>Type: string</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-topology">
                <title xml:id="auth-topology.title">Topology section</title>
                <para>The Topology configuration section defines the layers of the mix network and
                    the mix nodes in each layer.</para>
                <programlisting>[Topology]
                    
    [[Topology.Layers]]
    
        [[Topology.Layers.Nodes]]
            Identifier = "mix1"
            IdentityPublicKeyPem = "../mix1/identity.public.pem"
    
    [[Topology.Layers]]
    
        [[Topology.Layers.Nodes]]
            Identifier = "mix2"
            IdentityPublicKeyPem = "../mix2/identity.public.pem"
    
    [[Topology.Layers]]
    
        [[Topology.Layers.Nodes]]
            Identifier = "mix3"
            IdentityPublicKeyPem = "../mix3/identity.public.pem"</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Identifier</emphasis></para>
                        <para>A human readable mix node identifier.</para>
                        <para>Type:
                            string<?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?></para>
                    </listitem><?oxy_custom_end?>
                    <listitem>
                        <para><emphasis role="bold">IdentityPublicKeyPem</emphasis></para>
                        <para>Path and file name of a mix node's public identity signing key, also
                            known as the identity key, in PEM format.</para>
                        <para>Type: string</para>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="auth-sphinx-config">
                <title xml:id="auth-sphinx-config.title">SphinxGeometry section</title>
                <para>WARNING: The Sphinx Geometry section of the configuration MUST be programmatically generated.
                Do NOT modify the geometry by hand.
                </para>
                <para>The original Sphinx paper introduces the Sphinx nested encrypted packet format
using a NIKE (NIKE: non-interactive key exchange). NIKE Sphinx can be a hybrid post quantum construction simply by using a hybrid NIKE.
Our Sphinx implementation also can optionally use a KEM (KEM: key encapsulation mechanism) instead of a NIKE, however the trade-off is that
the packet's header will take up a lot of overhead because it must store a KEM ciphertext for each hop.
Katzenpost has a completely configurable Sphinx geometry which allows for any KEM or NIKE to be used.
                </para>
                <para>
                The Sphinx cryptographic packet format also uses these additional cryptographic primitives, the current Katzenpost
selection is:
                </para>
                <itemizedlist>
                <listitem><para>stream cipher: CTR-AES256</para>
                </listitem>
                <listitem><para>MAC: HMAC-SHA256</para>
                </listitem>
                <listitem><para>KDF: HKDF-SHA256</para>
                </listitem>
                <listitem><para>SPRP: AEZv5</para>
                </listitem>
                </itemizedlist>
                
				<para>
In Katzenpost the dirauths select the Sphinx geometry, each dirauth must agree with the other dirauths.
They publish the hash of the Sphinx Geometry in the PKI document so that the rest of the network entities
can validate their Sphinx Geometry.
                </para>
                &sphinxgeometry;
            </section>
        </section>
    </section>
    <section xml:id="server">
        <title xml:id="server.title">Mix, gateway, and service nodes</title>
        
<!--
            https://github.com/katzenpost/katzenpost/blob/c255fbbf421d5d9820553c18dc5dc6c9881ad547/server/config/config.go    
        
        // Config is the top level Katzenpost server configuration.
        type Config struct {
        Server         *Server
        Logging        *Logging
        ServiceNode    *ServiceNode
        Gateway        *Gateway
        PKI            *PKI
        Management     *Management
        SphinxGeometry *geo.Geometry
        Debug *Debug
        }        
        
-->
        
        
<!--        <para>Mix, gateway, and service nodes are all instances of a common <code>server</code>
            binary but using different configurations. They have the following functions</para>
        <itemizedlist>
            <listitem>
                <para>Mix nodes</para>
                <para>Conceptually for mix servers:</para>
                <para>- generate keys and send mix public keys to dirauths</para>
                <para>- listen for sphinx packets</para>
                <para>- mix, delay, decrypt, and relay sphinx packets</para>
            </listitem>
            <listitem>
                <para>Gateway nodes</para>
                <para>Conceptually for entry providers:</para>
                <para>- generate keys and send entry public keys to dirauths (and metadata like
                    public ips and ports)</para>
                <para>- listen for sphinx packets</para>
                <para>- delay, decrypt , and relay sphinx packets</para>
            </listitem>
            <listitem>
                <para>Service nodes</para>
                <para>Conceptually for service providers:</para>
                <para>- generate keys and send service public keys to dirauths (and metadata like
                    services such as ping and spool and public ips and ports)</para>
                <para>- listen for sphinx packets</para>
                <para>- decrypt, and respond to sphinx packets by sending responses to mixes</para>
            </listitem>
        </itemizedlist>
        <para>Each node instance of any type must be white-listed by the directory authorities in
            order to participate in the network.</para>
        <para>The dirauths generate a consensus document every twenty minutes. The clients fetch it
            every twenty minutes. The first time is from a randomly selected dirauth. Afterwards it
            is also possible to fetch this from an entry provider.</para>
        <para>Clients download the consensus and verify the signatures from the seven dirauths on
            that document.</para>
        <para>Then they do things in the network based on the content of the consensus
            document</para>
        <para>It has all the various service provider and mix and entry provider public keys</para>
        <para>It says stuff like the ping service is available on gnunet and anarres</para>
        <para>DR:</para>
        <para>Where did the client get the public keys to perform those verifications?</para>
        <para>JA:</para>
        <para>So the client then picks one of the ping services</para>
        <para>The consensus is signed by the dirauths, the public keys for alls servers except the
            dirauths is contained in this document</para>
        <para>Your client software has a configuration file with the dirauth public keys</para>
        <para>So you can chain the signatures together and verify from your trusted set of dirauth
            public keys</para>
        <para>And it’s less can and more that is the only way to do it</para>
        <para>What isn’t in the consensus is say; a Katzen user’s spool ID or the Katzen users
            public keys for making a double ratchet</para>
        <para>it’s critical to explain the concept of what exists at the start, what is dynamic, and
            on what basis do things change, etc</para>
        <para>So the root of everything is the dirauths and the consensus document</para>
        <para>From that the rest of the network is dynamically formed every twenty minutes and could
            change but generally it is static because we have eight people working on running the
            servers.</para>
        <para>I would model each layer differently</para>
        <para>And then merge them</para>
        <para>That merged set of items is all the things that have to work correctly to finally make
            an end-to-end-encrypted messenger pass messages to clients</para>
        <para/>
        <para><emphasis role="bold">Consensus</emphasis></para>
        <para>DR:</para>
        <para>Rather than diving into source code, I was hoping first for a general description of
            what consensus is being formed about, and what is being "voted" on. </para>
        <para>JA:</para>
        <para>Sure, we could talk about it - it would be helpful to look at the configuration for
            namenlos</para>
        <para>That should give you the concrete servers and services and types</para>
        <para>Then we can discuss it</para>
        <para>In general, a consensus here means that there are directory authorities. Let’s say n
            of them. X of n must agree for there to be a consensus. They express agreement by making
            a signature over their view of the network. A client verifies all their signatures and
            decides the view of the network based on the simple majority. So if x is 5 and n is 7, 5
            have to agree or there is no consensus. They do this every z minutes where in namenlos
            its z= 20</para>
        <para>So that’s “the network consensus”</para>
        <para>The dirauths are then in software configs like client or server configs.</para>
        <para>Every entry provider server and mix server and service provider server phone up each
            dirauth and tell them their metadata (I am a server at hostname and ip foo, bar, I am an
            entry provider, here are my public keys )</para>
        <para>They all do this regularly</para>
        <para>Then clients connect to one dirauth or more, get info on the network at the moment in
            question, and then they validate it</para>
        <para>This is how all clients have a uniform view of the network, its centralized around the
            consensus but no one party controls that - so we can call that distributed and
            decentralized in a sense</para>
        <para>Each type of service has different properties, and the consensus tries to take that
            into account</para>
        <para>So that’s the general story</para>
        <para>I would build up a diagram</para>
        <para>Generalize from text into an object like a graph made up of edges and vertices,
            labeled with type, then transition to names, then transition to putting the edge on a
            geographical map, and then we can blank it and add say, servers, do the same thing, then
            after each type is introduced, we merge the different dots; show the interconnected
            nature with different colors and fill patterns</para>
        <para>That’s the chatgpt prompt I would start with</para>
        <para>I think a model that is computer checkable would be useful, and then we could
            visualize it</para>
        <para>But if we think about it like that - its a series of graphs that we merge and then map
            onto a world map, then it becomes clear what the network is - in a physical and
            geographical and even political sense</para>
        <para>DR:</para>
        <para>So a client can connect directly to any of: entry node, exit node, directory
            authority?</para>
        <para>JA:</para>
        <para>Only to directory authorities (by picking one at random) and then to entry
            providers</para>
        <para>They send sphinx packets to the provider which are forwarded to the mixes, from that
            the final mix forwards packets to a service provider</para>
        <para>DR:</para>
        <para>OK. An entry provider is what I meant by entry node; there are also [!exit] providers,
            right? David S. says not to call them "exit providers".</para>
        <para>JA:</para>
        <para>There are no services that exit the network</para>
        <para>DR:</para>
        <para>What does the destination service provider do, then?</para>
        <para>JA:</para>
        <para>Depends on the service</para>
        <para>Katzen for example talks to service providers and stores messages in spools</para>
        <para>DR:</para>
        <para>Does Katzen periodically poll the service provider, and if so, how does it get that
            address?</para>
        <para>JA:</para>
        <para>So I run a spool provider node, and that means Katzen client software makes a
            connection to the entry provider, sends sphinx messages through the entry provider to
            the mixes and the mixes eventually forward it to my spool provider node, it receives the
            sphinx packets, and then stores some as messages in spools (like a mailbox or a mail
            spool) or it sends the contents of a spool to a Katzen client reading their
            mailbox</para>
        <para>I also run a PANDA service which means two people can use a password to rendezvous,
            exchange spool locations and public keys, and then after that they anonymously send and
            receive messages at their respective spools</para>
        <para>There is also a ping service</para>
        <para>It is just like the spool service - users enter through a provider node, send messages
            to the mixes, and then the mix forwards to the ping service provider - say me or gnunet
            or whoever else runs a pint service. The ping service sends a response immediately. The
            ping client tracks the time and prints ping messages in the terminal.</para>
        <para>Ping, panda, and spool are the three main services on the network and all these
            details are in the consensus document that is signed by the authorities</para>
        <para>DR:</para>
        <para>This is making sense. If I have it right, 1) client connects to dir auth, 2) dir auth
            provides address of entry, 3) client sends a payload to entry, 4) entry wraps payload
            and sends it to the mixes, 5) at some point the payload is received by the service
            provider, and 6) the service provider sends the payload to the client.</para>
        <para>Ping does this without authenticating? And Panda is used to establish a contact with
            another user, pretty much like Pond.</para>
        <para>JA:</para>
        <para>2) dirauth provides consensus</para>
        <para>3) client selects entry and builds a secure connection to the entry provider, now it
            can send sphinx packets to and through the provider</para>
        <para>4 ) entry decrypts messages sent to it, some are for the entry provider, some are
            addressed to a mix</para>
        <para>Ping is a concept and a service - the concept here is to send a response and measure
            time until a reply comes - the sphinx packet is a layered encryption data format</para>
        <para>So it has authentication</para>
        <para>The first hop is an encrypted tunnel, all sphinx packets go through the first
            hop</para>
        <para>So that connection is authenticated by the client validation of the consensus and the
            verification of the public key when connecting to the entry provider node</para>
        <para>Then sphinx packets are encrypted in reverse order</para>
        <para/>
        <para><emphasis role="bold">providers, mixes</emphasis></para>
        <para>Do providers also perform mix functions on the packets they touch?</para>
        <para>dawuud</para>
        <para>5:40 PM</para>
        <para>providers do mix messages but not all of them... we should fix this</para>
        <para>messages from the mixnet to the Provider services do not get mixed but probably
            should</para>
        <para>the services replies send out by the providers do get mixed</para>
        <para>and i'm not super clear on these other details but i'm prettu sure providers mix
            messages which the clients send to them. i'm not sure if they mix the replies.</para>
        <para>5:44 PM</para>
        <para>i'd have to audit the code to give you better answers... and.. @drquaithe and I have
            planned to write in great detail the katzenpost evauluation... we haven't started on
            that because we're trying to do the literature review first... but i can probably figure
            out the precise answers to this later this week if you need it</para>-->
        <section xml:id="mix-config">
            <title xml:id="mix-config.title">Configuring mix nodes</title>
            <para>The following configuration is drawn from the reference implementation in
                <filename>katzenpost/docker/voting_mixnet/mix1/katzenpost.toml</filename>. In a
                real-world mixnet, the component hosts would not be sharing a single IP address. For
                more information about the test mixnet, see <link linkend="container"
                    endterm="container.title">Using the Katzenpost test network</link>.</para>
            <section xml:id="mix-server-section-config">
                <title xml:id="mix-server-section-config.title">Server section</title>
                <para/>
                <para>
                    <programlisting>[Server]
  Identifier = "mix1"
  WireKEM = "xwing"
  PKISignatureScheme = "Ed25519"
  Addresses = ["127.0.0.1:30008"]
  OnlyAdvertiseAltAddresses = false
  MetricsAddress = "127.0.0.1:30009"
  DataDir = "/voting_mixnet/mix1"
  IsGatewayNode = false
  IsServiceNode = false
  [Server.AltAddresses]</programlisting>
                </para>
                    &serverconfig;
            </section>
            <section xml:id="mix-logging-config">
                <title xml:id="mix-logging-config.title">Logging section</title>
                    &logging;
            </section>
            <section xml:id="mix-pki-config">
                <title xml:id="mix-pki-config.title">PKI section</title>
                    &pki;                
            </section>
            <section xml:id="mix-management-config">
                <title xml:id="mix-management-config.title">Management section</title>
                    &management;
            </section>
            <section xml:id="mix-sphinx-config">
                <title xml:id="mix-sphinx-config.title">SphinxGeometry section</title>
                &sphinxgeometry;
            </section>
            <section xml:id="mix-debug-config">
                <title xml:id="mix-debug-config.title">Debug section</title>
                    &serverdebug;
            </section>
        </section>
        <section xml:id="gateway-config">
            <title xml:id="gateway-config.title">Configuring gateway nodes</title>
            <para>The following configuration is drawn from the reference implementation in
                    <filename>katzenpost/docker/voting_mixnet/gateway1/katzenpost.toml</filename>.
                In a real-world mixnet, the component hosts would not be sharing a single IP
                address. For more information about the test mixnet, see <link linkend="container"
                    endterm="container.title">Using the Katzenpost test network</link>.</para>
            <section xml:id="gateway-server-section-config">
                <title xml:id="gateway-server-section-config.title">Server section</title>
                <para/>
                <programlisting>[Server]
    Identifier = "gateway1"
    WireKEM = "xwing"
    PKISignatureScheme = "Ed25519"
    Addresses = ["127.0.0.1:30004"]
    OnlyAdvertiseAltAddresses = false
    MetricsAddress = "127.0.0.1:30005"
    DataDir = "/voting_mixnet/gateway1"
    IsGatewayNode = true
    IsServiceNode = false
    [Server.AltAddresses]
        TCP = ["localhost:30004"]</programlisting>
                &serverconfig;

            </section>
            <section xml:id="gateway-logging-config">
                <title xml:id="gateway-logging-config.title">Logging section</title>
                &logging;
            </section>
            <section xml:id="gateway-gateway-section-config">
                <?oxy_comment_start author="dwrob" timestamp="20240816T143000-0700" comment="Information needed."?>
                <title xml:id="gateway-gateway-section-config.title">Gateway section<?oxy_comment_end?></title>
                <para/>
                <programlisting>[Gateway]
    [Gateway.UserDB]
        Backend = "bolt"
            [Gateway.UserDB.Bolt]
                UserDB = "/voting_mixnet/gateway1/users.db"
    [Gateway.SpoolDB]
        Backend = "bolt"
            [Gateway.SpoolDB.Bolt]
                SpoolDB = "/voting_mixnet/gateway1/spool.db"</programlisting>
                <itemizedlist>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                    <listitem>
                        <para/>
                        <para/>
                    </listitem>
                </itemizedlist>
            </section>
            <section xml:id="gateway-pki-config">
                <title xml:id="gateway-pki-config.title">PKI section</title>
                    &pki;
            </section>
            <section xml:id="gateway-management-config">
                <title xml:id="gateway-management-config.title">Management section</title>
                    &management;
            </section>
            <section xml:id="gateway-sphinx-config">
                <title xml:id="gateway-sphinx-config.title">SphinxGeometry section</title>
                    &sphinxgeometry;
            </section>
            <section xml:id="gateway-debug-config">
                <title xml:id="gateway-debug-config.title">Debug section</title>
                &serverdebug;

                
            </section>
        </section>
        <section xml:id="service-config">
            <title xml:id="service-config.title">Configuring service nodes</title>
            <para>The following configuration is drawn from the reference implementation in
                <filename>katzenpost/docker/voting_mixnet/servicenode1/authority.toml</filename>.
                In a real-world mixnet, the component hosts would not be sharing a single IP
                address. For more information about the test mixnet, see <link linkend="container"
                    endterm="container.title">Using the Katzenpost test network</link>.</para>
            <section xml:id="service-server-section-config">
                <title xml:id="service-server-section-config.title">Server section</title>
                <para>The Server section contains mandatory information common to all nodes, for
                    example:</para>
                <programlisting>[Server]
    Identifier = "servicenode1"
    WireKEM = "xwing"
    PKISignatureScheme = "Ed25519"
    Addresses = ["127.0.0.1:30006"]
    OnlyAdvertiseAltAddresses = false
    MetricsAddress = "127.0.0.1:30007"
    DataDir = "/voting_mixnet/servicenode1"
    IsGatewayNode = false
    IsServiceNode = true
    [Server.AltAddresses]</programlisting>
                &serverconfig;

            </section>
            <section xml:id="service-logging-config">
                <title xml:id="service-logging-config.title">Logging section</title>
                &logging;
            </section>
            <section xml:id="service-servicenode-section-config">
                <title xml:id="service-servicenode-section-config.title">ServiceNode section</title>
                <!--https://github.com/katzenpost/katzenpost/blob/main/server/config/config.go#L470 defines the top level configuration.
https://github.com/katzenpost/katzenpost/blob/main/genconfig/main.go#L207 defines the per-service configurations.-->
                <para>The service node configuration section contains subsections with settings for
                    each service that Katzenpost supports. In a production network, the various
                    services would be hosted on dedicated systems.</para>
                <programlisting>[ServiceNode]
                    
    [[ServiceNode.Kaetzchen]]
        Capability = "echo"
        Endpoint = "+echo"
        Disable = false
    
    [[ServiceNode.CBORPluginKaetzchen]]
        Capability = "spool"
        Endpoint = "+spool"
        Command = "/voting_mixnet/memspool.alpine"
        MaxConcurrency = 1
        Disable = false
        [ServiceNode.CBORPluginKaetzchen.Config]
            data_store = "/voting_mixnet/servicenode1/memspool.storage"
            log_dir = "/voting_mixnet/servicenode1"
    
    [[ServiceNode.CBORPluginKaetzchen]]
        Capability = "pigeonhole"
        Endpoint = "+pigeonhole"
        Command = "/voting_mixnet/pigeonhole.alpine"
        MaxConcurrency = 1
        Disable = false
        [ServiceNode.CBORPluginKaetzchen.Config]
            db = "/voting_mixnet/servicenode1/map.storage"
            log_dir = "/voting_mixnet/servicenode1"
    
    [[ServiceNode.CBORPluginKaetzchen]]
        Capability = "panda"
        Endpoint = "+panda"
        Command = "/voting_mixnet/panda_server.alpine"
        MaxConcurrency = 1
        Disable = false
        [ServiceNode.CBORPluginKaetzchen.Config]
            fileStore = "/voting_mixnet/servicenode1/panda.storage"
            log_dir = "/voting_mixnet/servicenode1"
            log_level = "INFO"
    
    [[ServiceNode.CBORPluginKaetzchen]]
        Capability = "http"
        Endpoint = "+http"
        Command = "/voting_mixnet/proxy_server.alpine"
        MaxConcurrency = 1
        Disable = false
        [ServiceNode.CBORPluginKaetzchen.Config]
            host = "localhost:4242"
            log_dir = "/voting_mixnet/servicenode1"
            log_level = "DEBUG"</programlisting>
                <para><emphasis role="bold">Common parameters:</emphasis></para>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Capability</emphasis></para>
                        <para>The capability exposed by the agent.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Endpoint</emphasis></para>
                        <para>Endpoint is the provider side endpoint that the agent will
                            accept requests at. While not required by the spec, this server
                            only supports Endpoints that are lower-case local-parts of an
                            e-mail address.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Command</emphasis></para>
                        <para>Command is the full file path to the external plugin program
                        that implements this Kaetzchen service.</para>
                        <para>Type: string</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">MaxConcurrency</emphasis></para>
                        <para>MaxConcurrency is the number of worker goroutines to start for this service.</para>
                        <para>Type: int</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Config</emphasis></para>
                        <para>The extra per agent arguments to be passed to the agent's initialization routine.</para>
                        <para>Type: map[string]interface{}</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Disable</emphasis></para>
                        <para>disabled a configured agent.</para>
                        <para>Type: bool</para>
                    </listitem>
                </itemizedlist>
                <?oxy_comment_start author="dwrob" timestamp="20240816T141621-0700" comment="About CBOR:

https://pkg.go.dev/github.com/katzenpost/katzenpost@v0.0.35/server/cborplugin#ResponseFactory

Package cborplugin is a plugin system allowing mix network services to be added in any language. It communicates queries and responses to and from the mix server using CBOR over UNIX domain socket. Beyond that, a client supplied SURB is used to route the response back to the client as described in our Kaetzchen specification document: "?>
                <para><emphasis role="bold">Per-service
                    parameters:<?oxy_comment_end?></emphasis></para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><?oxy_comment_start author="dwrob" timestamp="20240816T124622-0700" comment="Needs explanation"?><?oxy_custom_start type="oxy_content_highlight" color="255,255,0" mid="36"?><emphasis
                                    role="bold"
                            >Kaetzchen</emphasis><?oxy_comment_end?></para><?oxy_custom_end mid="36"?>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">spool</emphasis></para>
                            <itemizedlist>
                                <listitem>
                                    <para><emphasis role="bold">data_store</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                                <listitem>
                                    <para><emphasis role="bold">log_dir</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">pigeonhole</emphasis></para>
                            <itemizedlist>
                                <listitem>
                                    <para><emphasis role="bold">db</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                                <listitem>
                                    <para><emphasis role="bold">log_dir</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">panda</emphasis></para>
                            <itemizedlist>
                                <listitem>
                                    <para><emphasis role="bold">fileStore</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                                <listitem>
                                    <para><emphasis role="bold">log_dir</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                                <listitem>
                                    <para><emphasis role="bold">log_level</emphasis></para>
                                    <para>Supported values are ERROR | WARNING | NOTICE |INFO |
                                        DEBUG.</para>
                                    <para>Type: string</para>
                                    <warning>
                                        <para>The DEBUG log level is unsafe for production
                                            use.</para>
                                    </warning>
                                    <para>Type: string</para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">http</emphasis></para>
                            <itemizedlist>
                                <listitem>
                                    <para><emphasis role="bold">host</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                                <listitem>
                                    <para><emphasis role="bold">log_dir</emphasis></para>
                                    <para/>
                                    <para>Type: </para>
                                </listitem>
                                <listitem>
                                    <para><emphasis role="bold">log_level</emphasis></para>
                                    <para>Supported values are ERROR | WARNING | NOTICE |INFO |
                                        DEBUG.</para>
                                    <para>Type: string</para>
                                    <warning>
                                        <para>The DEBUG log level is unsafe for production
                                            use.</para>
                                    </warning>
                                    <para>Type: string</para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="service-pki-config">
                <title xml:id="service-pki-config.title">PKI section</title>
                    &pki;
            </section>
            <section xml:id="service-management-config">
                <title xml:id="service-management-config.title">Management section</title>
                    &management;
            </section>
            <section xml:id="service-sphinx-config">
                <title xml:id="service-sphinx-config.title">SphinxGeometry section</title>
                    &sphinxgeometry;
            </section>
            <section xml:id="service-debug-config">
                <title xml:id="service-debug-config.title">Debug section</title>
                &serverdebug;
            </section>
<!--            <section>
                <?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>
                <title>Old "Provider" section<?oxy_custom_end?></title>
                <para><?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>The
                    Provider section specifies the Provider configuration. This section of the
                    configuration has sensible defaults for every field and can therefore be omitted
                    unless you wish to deviate from the defaults.</para>
                <para>The top-level Provider configuration parameters include:</para>
                <itemizedlist>
                    <listitem>
                        <para>EnableUserRegistrationHTTP</para>
                        <para> if set to </para>
                        <para>true</para>
                        <para> then the HTTP registration service will be enabled and the </para>
                        <para>UserRegistrationHTTPAddresses</para>
                        <para> option must also be set.</para>
                    </listitem>
                    <listitem>
                        <para>UserRegistrationHTTPAddresses</para>
                        <para> is set to a list of TCP addresses which include the IP address of the
                            interface to listen on and the TCP port.</para>
                    </listitem>
                    <listitem>
                        <para>BinaryRecipients</para>
                        <para> if set to </para>
                        <para>true</para>
                        <para> disables all Provider side recipient pre-processing, including
                            removing trailing NUL bytes, case normalization, and delimiter
                            support.</para>
                    </listitem>
                    <listitem>
                        <para>CaseSensitiveRecipients</para>
                        <para> if set to </para>
                        <para>true</para>
                        <para> disables recipient case normalization. If left unset, all user names
                            will be converted to lower case.</para>
                    </listitem>
                    <listitem>
                        <para>RecipientDelimiter</para>
                        <para> is the set of characters that separates a user name from it's
                            extension (eg: alice+foo).</para>
                    </listitem>
                    <listitem>
                        <para>AltAddresses</para>
                        <para> is the map of extra transports and addresses at which the Provider is
                            reachable by clients. The most useful alternative transport is likely
                            ("tcp") (core/pki.TransportTCP).</para>
                    </listitem><?oxy_custom_end?>
                </itemizedlist>
                <anchor xml:id="user-content-provider-http-registration"/>
            </section>
            <?oxy_custom_start type="oxy_content_highlight" color="235,192,230"?>
            <section>
                <title>Provider HTTP Registration</title>
                <para>Here's an example TOML configuration section that demonstrates how to
                    configure a HTTP Registration service that facilitates account
                    registration:</para>
                <programlisting>[Provider]
                    
                    EnableUserRegistrationHTTP = true
                    UserRegistrationHTTPAddresses = [ "127.0.0.1:8080"]
                </programlisting>
                <para><emphasis role="bold">Warning</emphasis></para>
                <para>This configuration example configures the HTTP registration service to listen
                    on the loopback interface on TCP port 8080. There is NO authentication, TLS
                    encryption or abuse mitigation at all; this is left as an exercise for the
                    discerning systems administrator who can utilize some kind of proxy service to
                    mitigate abuse and provide TLS authentication.</para>
                <anchor xml:id="user-content-kaetzchen-configuration"/>
                <section>
                    <title>Kaetzchen Configuration</title>
                    <para>Kaetzchen are a simple kind of Provider-side service which receives a
                        request and replies with a response message. We here discuss built-in
                        internal kaetzchen services. (see next section for external kaetzchen plugin
                        system)</para>
                    <para>Consider the following simple configuration example where we configure the
                        loop and keyserver services:</para>
                    <programlisting>[Provider]
                        
                        [[Provider.Kaetzchen]]
                        Capability = "loop"
                        Endpoint = "+loop"
                        Disable = false
                        
                        [[Provider.Kaetzchen]]
                        Capability = "keyserver"
                        Endpoint = "+keyserver"
                        Disable = false
                    </programlisting>
                    <para>The Kaetzchen field is the list of configured Kaetzchen (auto-responder
                        agents) for this provider. In the above example we configured two Kaetzchen,
                        keyserver and loop which are required by the mailproxy client.</para>
                    <para>Lets review the Kaetzchen configuration parameters:</para>
                    <itemizedlist>
                        <listitem>
                            <para>Capability</para>
                            <para> is the capability exposed by the agent.</para>
                        </listitem>
                        <listitem>
                            <para>Endpoint</para>
                            <para> is the provider side endpoint that the agent will accept requests
                                at. While not required by the spec, this server only supports
                                Endpoints that are lower-case local-parts of an e-mail address. By
                                convention these endpoint strings begin with </para>
                            <para>+</para>
                            <para>.</para>
                        </listitem>
                        <listitem>
                            <para>Config</para>
                            <para> is the extra per agent arguments to be passed to the agent's
                                initialization routine.</para>
                        </listitem>
                        <listitem>
                            <para>Disable</para>
                            <para> disabled a configured agent.</para>
                        </listitem>
                    </itemizedlist>
                    <anchor xml:id="user-content-external-kaetzchen-plugin-configuration"/>
                </section>
                <section>
                    <title>External Kaetzchen Plugin Configuration</title>
                    <para>Currently the Katzenpost server external kaetzchen plugin system uses CBOR
                        over HTTP over UNIX domain socket to communicate with plugin programs. That
                        is to say, the katzenpost server will spin up each plugin program one or
                        more times as specified by it's <code>MaxConcurrency</code> parameter,
                        connect to it as a HTTP client and pipeline Kaetzchen queries.</para>
                    <para>Here's a configuration example for the external currency service</para>
                    <programlisting>[[Provider.CBORPluginKaetzchen]]
                        Capability = "zec"
                        Endpoint = "+zec"
                        Disable = false
                        Command = "/home/user/test_mixnet/bin/currency"
                        MaxConcurrency = 10
                        [Provider.PluginKaetzchen.Config]
                        log_dir = "/home/user/test_mixnet/zec_tx_logs"
                        f = "/home/user/test_mixnet/currency_zec/curreny.toml"
                    </programlisting>
                    <para>We've written echo services in golang and rust as an example here: <link
                        xlink:href="https://github.com/katzenpost/server_plugins"
                        >https://github.com/katzenpost/server_plugins</link></para>
                    <anchor xml:id="user-content-provider-user-database-configuration"/>
                </section>
                <section>
                    <title>Provider User Database Configuration</title>
                    <para><code>UserDB</code> is the user database configuration. If left empty the
                        simple BoltDB backed user database will be used with the default database. A
                        simple configuration example:</para>
                    <programlisting>[Provider.UserDB]
                        Backend = "bolt"
                        
                        [Provider.UserDB.Bolt]
                        UserDB = "my_users.db"
                    </programlisting>
                    <itemizedlist>
                        <listitem>
                            <para>Backend</para>
                            <para> is the active userdb backend. If left empty, the BoltUserDB
                                backend will be used (bolt).</para>
                        </listitem>
                    </itemizedlist>
                    <para>If the <code>bolt</code> backend is specified there is one configuration
                        parameter available under this section:</para>
                    <itemizedlist>
                        <listitem>
                            <para>UserDB</para>
                            <para> is the path to the user database. If left empty it will use
                                users.db under the DataDir.</para>
                        </listitem>
                    </itemizedlist>
                    <para>Next we will examine a configuration example which demonstrates using a
                        user database via HTTP:</para>
                    <programlisting>[Provider.UserDB]
                        [Provider.UserDB.ExternUserDB]
                        ProviderURL = "http://localhost:8080/"
                    </programlisting>
                    <itemizedlist>
                        <listitem>
                            <para>ExternUserDB</para>
                            <para> is the external http user authentication mechanism.</para>
                        </listitem>
                        <listitem>
                            <para>ProviderURL</para>
                            <para> is the base url used for the external provider authentication
                                API.</para>
                        </listitem>
                    </itemizedlist>
                    <anchor xml:id="user-content-provider-spool-database-configuration"/>
                </section>
                <section>
                    <title>Provider Spool Database Configuration</title>
                    <para>The Provider spool database stores received messages for later retreival
                        by clients. A simple configuration example follows:</para>
                    <programlisting>[Provider.SpoolDB]
                        Backend = "bolt"
                        
                        [Provider.SpoolDB.Bolt]
                        SpoolDB = "my_spool.db"
                    </programlisting>
                    <itemizedlist>
                        <listitem>
                            <para>SpoolDB</para>
                            <para> is the path to the user message spool. If left empty, it will
                                default to spool.db under the DataDir.</para>
                        </listitem>
                    </itemizedlist>
                    <anchor xml:id="user-content-using-the-postgres-sql-database-backend"/>
                </section>
                <section>
                    <title>Using the Postgres SQL Database Backend</title>
                    <para>Lastly, we will explore how to use a SQL database as the backend for the
                        user and spool databases, for example:</para>
                    <programlisting>[Provider]
                        [Provider.SQLDB]
                        Backend = "pgx"
                        DataSourceName = "postgresql://provider:s3cr3tp0stgr355@127.0.0.1:5433/katzenpost"
                        [Provider.SpoolDB]
                        Backend = "sql"
                        [Provider.UserDB]
                        Backend = "sql"
                    </programlisting>
                    <para>This configuration sample demonstrates how to use a Postgres database for
                        both the user database and the spool database. The <code>Backend</code>
                        parameter is set to <code>pgx</code> which means "use a postgresql
                        database".</para>
                    <itemizedlist>
                        <listitem>
                            <para>DataSourceName</para>
                            <para> is the SQL data source name or URI. The format of this parameter
                                is dependent on the database driver being used.</para>
                        </listitem>
                    </itemizedlist>
                    <para>Setup the Postgres SQL database backend:</para>
                    <orderedlist>
                        <listitem>
                            <para>Install postgres Postgres 9.5 or later is required. On a debian
                                system you can install it like so:</para>
                            <programlisting>apt install postgresql
                            </programlisting>
                        </listitem>
                        <listitem>
                            <para>Configure postgres access The pg_hba.conf file is the place to
                                configure access to the databases. It's parsed from top to bottom,
                                first matching rule is applied. You probably need to add a rule for
                                your 'provider' user fairly early. On a debian system this file may
                                be located here:</para>
                            <programlisting>/etc/postgresql/9.6/main/pg_hba.conf
                            </programlisting>
                            <para>Start a shell as the postgres user. If you are superuser you can
                                use su or sudo to start the shell as postgres like:</para>
                            <programlisting>sudo -u postgres
                            </programlisting>
                            <para>or without sudo:</para>
                            <programlisting>su - postgres
                            </programlisting>
                            <para>Add the database user "provider":</para>
                            <programlisting>createuser -U postgres provider
                            </programlisting>
                            <para>Add a database:</para>
                            <programlisting>createdb -U postgres -O provider katzenpost
                            </programlisting>
                            <para>Start the postgres shell:</para>
                            <programlisting>psql
                            </programlisting>
                            <para>Set the password for your new user:</para>
                            <programlisting>ALTER USER provider WITH PASSWORD 's3cr3tp0stgr355';
                            </programlisting>
                            <para>Test to see if you can connect:</para>
                            <programlisting>psql -U provider -h 127.0.0.1 katzenpost
                            </programlisting>
                            <para>If all goes fine, it's time to load the SQL, that creates the
                                Katzenpost database schema and stored procedures:</para>
                            <programlisting>psql -U provider -\-password -d katzenpost -h 127.0.0.1 -f create_database-postgresql.sql
                            </programlisting>
                            <para>That sql script is located in our <code>server</code> git
                                repository, here: <link
                                    xlink:href="https://github.com/katzenpost/server/blob/master/internal/sqldb/create_database-postgresql.sql"
                                    >https://github.com/katzenpost/server/blob/master/internal/sqldb/create_database-postgresql.sql</link></para>
                        </listitem>
                        <listitem>
                            <para>Start the Katzenpost server.</para>
                        </listitem><?oxy_custom_end?>
                    </orderedlist>
                </section>
            </section>-->
        </section>
    </section>
<!--    <section xml:id="clients">
        <title xml:id="clients.title">Clients</title>
        <para/>
    </section>-->
</chapter>
