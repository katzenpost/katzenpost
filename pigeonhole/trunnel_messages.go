// Code generated by trunnel. DO NOT EDIT.

package pigeonhole

import (
	"encoding/binary"
	"errors"
)

type CourierEnvelope struct {
	IntermediateReplicas [2]uint8
	Dek1                 [60]uint8
	Dek2                 [60]uint8
	ReplyIndex           uint8
	Epoch                uint64
	SenderPubkeyLen      uint16
	SenderPubkey         []uint8
	CiphertextLen        uint32
	Ciphertext           []uint8
}

func (c *CourierEnvelope) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 2; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.IntermediateReplicas[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 60; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.Dek1[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 60; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.Dek2[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.ReplyIndex = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 8 {
			return nil, errors.New("data too short")
		}
		c.Epoch = binary.BigEndian.Uint64(cur)
		cur = cur[8:]
	}
	{
		if len(cur) < 2 {
			return nil, errors.New("data too short")
		}
		c.SenderPubkeyLen = binary.BigEndian.Uint16(cur)
		cur = cur[2:]
	}
	{
		c.SenderPubkey = make([]uint8, int(c.SenderPubkeyLen))
		for idx := 0; idx < int(c.SenderPubkeyLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.SenderPubkey[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		c.CiphertextLen = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		c.Ciphertext = make([]uint8, int(c.CiphertextLen))
		for idx := 0; idx < int(c.CiphertextLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.Ciphertext[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseCourierEnvelope(data []byte) (*CourierEnvelope, error) {
	c := new(CourierEnvelope)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CourierEnvelope) encodeBinary() []byte {
	var buf []byte
	for idx := 0; idx < 2; idx++ {
		buf = append(buf, byte(c.IntermediateReplicas[idx]))
	}
	for idx := 0; idx < 60; idx++ {
		buf = append(buf, byte(c.Dek1[idx]))
	}
	for idx := 0; idx < 60; idx++ {
		buf = append(buf, byte(c.Dek2[idx]))
	}
	buf = append(buf, byte(c.ReplyIndex))
	{
		tmp := make([]byte, 8)
		binary.BigEndian.PutUint64(tmp, c.Epoch)
		buf = append(buf, tmp...)
	}
	{
		tmp := make([]byte, 2)
		binary.BigEndian.PutUint16(tmp, c.SenderPubkeyLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(c.SenderPubkeyLen); idx++ {
		buf = append(buf, byte(c.SenderPubkey[idx]))
	}
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, c.CiphertextLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(c.CiphertextLen); idx++ {
		buf = append(buf, byte(c.Ciphertext[idx]))
	}
	return buf
}

func (c *CourierEnvelope) MarshalBinary() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	return c.encodeBinary(), nil
}

func (c *CourierEnvelope) validate() error {
	if len(c.IntermediateReplicas) != 2 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.IntermediateReplicas); idx++ {
	}
	if len(c.Dek1) != 60 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.Dek1); idx++ {
	}
	if len(c.Dek2) != 60 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.Dek2); idx++ {
	}
	if len(c.SenderPubkey) != int(c.SenderPubkeyLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.SenderPubkey); idx++ {
	}
	if len(c.Ciphertext) != int(c.CiphertextLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.Ciphertext); idx++ {
	}
	return nil
}

type CourierEnvelopeReply struct {
	EnvelopeHash [32]uint8
	ReplyIndex   uint8
	PayloadLen   uint32
	Payload      []uint8
	ErrorCode    uint8
}

func (c *CourierEnvelopeReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 32; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.EnvelopeHash[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.ReplyIndex = cur[0]
		cur = cur[1:]
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		c.PayloadLen = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		c.Payload = make([]uint8, int(c.PayloadLen))
		for idx := 0; idx < int(c.PayloadLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.Payload[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.ErrorCode = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

func ParseCourierEnvelopeReply(data []byte) (*CourierEnvelopeReply, error) {
	c := new(CourierEnvelopeReply)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CourierEnvelopeReply) encodeBinary() []byte {
	var buf []byte
	for idx := 0; idx < 32; idx++ {
		buf = append(buf, byte(c.EnvelopeHash[idx]))
	}
	buf = append(buf, byte(c.ReplyIndex))
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, c.PayloadLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(c.PayloadLen); idx++ {
		buf = append(buf, byte(c.Payload[idx]))
	}
	buf = append(buf, byte(c.ErrorCode))
	return buf
}

func (c *CourierEnvelopeReply) MarshalBinary() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	return c.encodeBinary(), nil
}

func (c *CourierEnvelopeReply) validate() error {
	if len(c.EnvelopeHash) != 32 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.EnvelopeHash); idx++ {
	}
	if len(c.Payload) != int(c.PayloadLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.Payload); idx++ {
	}
	return nil
}

type CourierQuery struct {
	QueryType   uint8
	Envelope    *CourierEnvelope
	CopyCommand *CopyCommand
}

func (c *CourierQuery) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.QueryType = cur[0]
		if !(c.QueryType == 0 || c.QueryType == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		switch {
		case c.QueryType == 0:
			{
				var err error
				c.Envelope = new(CourierEnvelope)
				cur, err = c.Envelope.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		case c.QueryType == 1:
			{
				var err error
				c.CopyCommand = new(CopyCommand)
				cur, err = c.CopyCommand.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	return cur, nil
}

func ParseCourierQuery(data []byte) (*CourierQuery, error) {
	c := new(CourierQuery)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CourierQuery) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(c.QueryType))
	switch {
	case c.QueryType == 0:
		if c.Envelope != nil {
			buf = append(buf, c.Envelope.encodeBinary()...)
		}
	case c.QueryType == 1:
		if c.CopyCommand != nil {
			buf = append(buf, c.CopyCommand.encodeBinary()...)
		}
	}
	return buf
}

func (c *CourierQuery) MarshalBinary() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	return c.encodeBinary(), nil
}

func (c *CourierQuery) validate() error {
	if !(c.QueryType == 0 || c.QueryType == 1) {
		return errors.New("integer constraint violated")
	}
	switch {
	case c.QueryType == 0:
		if c.Envelope != nil {
			if err := c.Envelope.validate(); err != nil {
				return err
			}
		}
	case c.QueryType == 1:
		if c.CopyCommand != nil {
			if err := c.CopyCommand.validate(); err != nil {
				return err
			}
		}
	}
	return nil
}

type CourierQueryReply struct {
	ReplyType        uint8
	EnvelopeReply    *CourierEnvelopeReply
	CopyCommandReply *CopyCommandReply
}

func (c *CourierQueryReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.ReplyType = cur[0]
		if !(c.ReplyType == 0 || c.ReplyType == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		switch {
		case c.ReplyType == 0:
			{
				var err error
				c.EnvelopeReply = new(CourierEnvelopeReply)
				cur, err = c.EnvelopeReply.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		case c.ReplyType == 1:
			{
				var err error
				c.CopyCommandReply = new(CopyCommandReply)
				cur, err = c.CopyCommandReply.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	return cur, nil
}

func ParseCourierQueryReply(data []byte) (*CourierQueryReply, error) {
	c := new(CourierQueryReply)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CourierQueryReply) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(c.ReplyType))
	switch {
	case c.ReplyType == 0:
		if c.EnvelopeReply != nil {
			buf = append(buf, c.EnvelopeReply.encodeBinary()...)
		}
	case c.ReplyType == 1:
		if c.CopyCommandReply != nil {
			buf = append(buf, c.CopyCommandReply.encodeBinary()...)
		}
	}
	return buf
}

func (c *CourierQueryReply) MarshalBinary() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	return c.encodeBinary(), nil
}

func (c *CourierQueryReply) validate() error {
	if !(c.ReplyType == 0 || c.ReplyType == 1) {
		return errors.New("integer constraint violated")
	}
	switch {
	case c.ReplyType == 0:
		if c.EnvelopeReply != nil {
			if err := c.EnvelopeReply.validate(); err != nil {
				return err
			}
		}
	case c.ReplyType == 1:
		if c.CopyCommandReply != nil {
			if err := c.CopyCommandReply.validate(); err != nil {
				return err
			}
		}
	}
	return nil
}

type ReplicaRead struct {
	BoxID [32]uint8
}

func (r *ReplicaRead) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 32; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.BoxID[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseReplicaRead(data []byte) (*ReplicaRead, error) {
	r := new(ReplicaRead)
	_, err := r.Parse(data)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (r *ReplicaRead) encodeBinary() []byte {
	var buf []byte
	for idx := 0; idx < 32; idx++ {
		buf = append(buf, byte(r.BoxID[idx]))
	}
	return buf
}

func (r *ReplicaRead) MarshalBinary() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	return r.encodeBinary(), nil
}

func (r *ReplicaRead) validate() error {
	if len(r.BoxID) != 32 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.BoxID); idx++ {
	}
	return nil
}

type ReplicaReadReply struct {
	ErrorCode  uint8
	BoxID      [32]uint8
	Signature  [64]uint8
	PayloadLen uint32
	Payload    []uint8
}

func (r *ReplicaReadReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		r.ErrorCode = cur[0]
		cur = cur[1:]
	}
	{
		for idx := 0; idx < 32; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.BoxID[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 64; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.Signature[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		r.PayloadLen = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		r.Payload = make([]uint8, int(r.PayloadLen))
		for idx := 0; idx < int(r.PayloadLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.Payload[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseReplicaReadReply(data []byte) (*ReplicaReadReply, error) {
	r := new(ReplicaReadReply)
	_, err := r.Parse(data)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (r *ReplicaReadReply) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(r.ErrorCode))
	for idx := 0; idx < 32; idx++ {
		buf = append(buf, byte(r.BoxID[idx]))
	}
	for idx := 0; idx < 64; idx++ {
		buf = append(buf, byte(r.Signature[idx]))
	}
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, r.PayloadLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(r.PayloadLen); idx++ {
		buf = append(buf, byte(r.Payload[idx]))
	}
	return buf
}

func (r *ReplicaReadReply) MarshalBinary() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	return r.encodeBinary(), nil
}

func (r *ReplicaReadReply) validate() error {
	if len(r.BoxID) != 32 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.BoxID); idx++ {
	}
	if len(r.Signature) != 64 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.Signature); idx++ {
	}
	if len(r.Payload) != int(r.PayloadLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.Payload); idx++ {
	}
	return nil
}

type ReplicaInnerMessage struct {
	MessageType uint8
	ReadMsg     *ReplicaRead
	WriteMsg    *ReplicaWrite
}

func (r *ReplicaInnerMessage) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		r.MessageType = cur[0]
		if !(r.MessageType == 0 || r.MessageType == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		switch {
		case r.MessageType == 0:
			{
				var err error
				r.ReadMsg = new(ReplicaRead)
				cur, err = r.ReadMsg.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		case r.MessageType == 1:
			{
				var err error
				r.WriteMsg = new(ReplicaWrite)
				cur, err = r.WriteMsg.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	return cur, nil
}

func ParseReplicaInnerMessage(data []byte) (*ReplicaInnerMessage, error) {
	r := new(ReplicaInnerMessage)
	_, err := r.Parse(data)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (r *ReplicaInnerMessage) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(r.MessageType))
	switch {
	case r.MessageType == 0:
		if r.ReadMsg != nil {
			buf = append(buf, r.ReadMsg.encodeBinary()...)
		}
	case r.MessageType == 1:
		if r.WriteMsg != nil {
			buf = append(buf, r.WriteMsg.encodeBinary()...)
		}
	}
	return buf
}

func (r *ReplicaInnerMessage) MarshalBinary() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	return r.encodeBinary(), nil
}

func (r *ReplicaInnerMessage) validate() error {
	if !(r.MessageType == 0 || r.MessageType == 1) {
		return errors.New("integer constraint violated")
	}
	switch {
	case r.MessageType == 0:
		if r.ReadMsg != nil {
			if err := r.ReadMsg.validate(); err != nil {
				return err
			}
		}
	case r.MessageType == 1:
		if r.WriteMsg != nil {
			if err := r.WriteMsg.validate(); err != nil {
				return err
			}
		}
	}
	return nil
}

type ReplicaWrite struct {
	BoxID      [32]uint8
	Signature  [64]uint8
	PayloadLen uint32
	Payload    []uint8
}

func (r *ReplicaWrite) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 32; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.BoxID[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 64; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.Signature[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		r.PayloadLen = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		r.Payload = make([]uint8, int(r.PayloadLen))
		for idx := 0; idx < int(r.PayloadLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			r.Payload[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseReplicaWrite(data []byte) (*ReplicaWrite, error) {
	r := new(ReplicaWrite)
	_, err := r.Parse(data)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (r *ReplicaWrite) encodeBinary() []byte {
	var buf []byte
	for idx := 0; idx < 32; idx++ {
		buf = append(buf, byte(r.BoxID[idx]))
	}
	for idx := 0; idx < 64; idx++ {
		buf = append(buf, byte(r.Signature[idx]))
	}
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, r.PayloadLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(r.PayloadLen); idx++ {
		buf = append(buf, byte(r.Payload[idx]))
	}
	return buf
}

func (r *ReplicaWrite) MarshalBinary() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	return r.encodeBinary(), nil
}

func (r *ReplicaWrite) validate() error {
	if len(r.BoxID) != 32 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.BoxID); idx++ {
	}
	if len(r.Signature) != 64 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.Signature); idx++ {
	}
	if len(r.Payload) != int(r.PayloadLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(r.Payload); idx++ {
	}
	return nil
}

type ReplicaMessageReplyInnerMessage struct {
	MessageType uint8
	ReadReply   *ReplicaReadReply
	WriteReply  *ReplicaWriteReply
}

func (r *ReplicaMessageReplyInnerMessage) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		r.MessageType = cur[0]
		if !(r.MessageType == 0 || r.MessageType == 1) {
			return nil, errors.New("integer constraint violated")
		}
		cur = cur[1:]
	}
	{
		switch {
		case r.MessageType == 0:
			{
				var err error
				r.ReadReply = new(ReplicaReadReply)
				cur, err = r.ReadReply.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		case r.MessageType == 1:
			{
				var err error
				r.WriteReply = new(ReplicaWriteReply)
				cur, err = r.WriteReply.Parse(cur)
				if err != nil {
					return nil, err
				}
			}
		}
	}
	return cur, nil
}

func ParseReplicaMessageReplyInnerMessage(data []byte) (*ReplicaMessageReplyInnerMessage, error) {
	r := new(ReplicaMessageReplyInnerMessage)
	_, err := r.Parse(data)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (r *ReplicaMessageReplyInnerMessage) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(r.MessageType))
	switch {
	case r.MessageType == 0:
		if r.ReadReply != nil {
			buf = append(buf, r.ReadReply.encodeBinary()...)
		}
	case r.MessageType == 1:
		if r.WriteReply != nil {
			buf = append(buf, r.WriteReply.encodeBinary()...)
		}
	}
	return buf
}

func (r *ReplicaMessageReplyInnerMessage) MarshalBinary() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	return r.encodeBinary(), nil
}

func (r *ReplicaMessageReplyInnerMessage) validate() error {
	if !(r.MessageType == 0 || r.MessageType == 1) {
		return errors.New("integer constraint violated")
	}
	switch {
	case r.MessageType == 0:
		if r.ReadReply != nil {
			if err := r.ReadReply.validate(); err != nil {
				return err
			}
		}
	case r.MessageType == 1:
		if r.WriteReply != nil {
			if err := r.WriteReply.validate(); err != nil {
				return err
			}
		}
	}
	return nil
}

type ReplicaWriteReply struct {
	ErrorCode uint8
}

func (r *ReplicaWriteReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		r.ErrorCode = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

func ParseReplicaWriteReply(data []byte) (*ReplicaWriteReply, error) {
	r := new(ReplicaWriteReply)
	_, err := r.Parse(data)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (r *ReplicaWriteReply) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(r.ErrorCode))
	return buf
}

func (r *ReplicaWriteReply) MarshalBinary() ([]byte, error) {
	if err := r.validate(); err != nil {
		return nil, err
	}
	return r.encodeBinary(), nil
}

func (r *ReplicaWriteReply) validate() error {
	return nil
}

type Box struct {
	BoxID      [32]uint8
	PayloadLen uint32
	Payload    []uint8
	Signature  [64]uint8
}

func (b *Box) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		for idx := 0; idx < 32; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			b.BoxID[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		b.PayloadLen = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		b.Payload = make([]uint8, int(b.PayloadLen))
		for idx := 0; idx < int(b.PayloadLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			b.Payload[idx] = cur[0]
			cur = cur[1:]
		}
	}
	{
		for idx := 0; idx < 64; idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			b.Signature[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseBox(data []byte) (*Box, error) {
	b := new(Box)
	_, err := b.Parse(data)
	if err != nil {
		return nil, err
	}
	return b, nil
}

func (b *Box) encodeBinary() []byte {
	var buf []byte
	for idx := 0; idx < 32; idx++ {
		buf = append(buf, byte(b.BoxID[idx]))
	}
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, b.PayloadLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(b.PayloadLen); idx++ {
		buf = append(buf, byte(b.Payload[idx]))
	}
	for idx := 0; idx < 64; idx++ {
		buf = append(buf, byte(b.Signature[idx]))
	}
	return buf
}

func (b *Box) MarshalBinary() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	return b.encodeBinary(), nil
}

func (b *Box) validate() error {
	if len(b.BoxID) != 32 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(b.BoxID); idx++ {
	}
	if len(b.Payload) != int(b.PayloadLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(b.Payload); idx++ {
	}
	if len(b.Signature) != 64 {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(b.Signature); idx++ {
	}
	return nil
}

type CopyCommand struct {
	WriteCapLen uint32
	WriteCap    []uint8
}

func (c *CopyCommand) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 4 {
			return nil, errors.New("data too short")
		}
		c.WriteCapLen = binary.BigEndian.Uint32(cur)
		cur = cur[4:]
	}
	{
		c.WriteCap = make([]uint8, int(c.WriteCapLen))
		for idx := 0; idx < int(c.WriteCapLen); idx++ {
			if len(cur) < 1 {
				return nil, errors.New("data too short")
			}
			c.WriteCap[idx] = cur[0]
			cur = cur[1:]
		}
	}
	return cur, nil
}

func ParseCopyCommand(data []byte) (*CopyCommand, error) {
	c := new(CopyCommand)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CopyCommand) encodeBinary() []byte {
	var buf []byte
	{
		tmp := make([]byte, 4)
		binary.BigEndian.PutUint32(tmp, c.WriteCapLen)
		buf = append(buf, tmp...)
	}
	for idx := 0; idx < int(c.WriteCapLen); idx++ {
		buf = append(buf, byte(c.WriteCap[idx]))
	}
	return buf
}

func (c *CopyCommand) MarshalBinary() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	return c.encodeBinary(), nil
}

func (c *CopyCommand) validate() error {
	if len(c.WriteCap) != int(c.WriteCapLen) {
		return errors.New("array length constraint violated")
	}
	for idx := 0; idx < len(c.WriteCap); idx++ {
	}
	return nil
}

type CopyCommandReply struct {
	ErrorCode uint8
}

func (c *CopyCommandReply) Parse(data []byte) ([]byte, error) {
	cur := data
	{
		if len(cur) < 1 {
			return nil, errors.New("data too short")
		}
		c.ErrorCode = cur[0]
		cur = cur[1:]
	}
	return cur, nil
}

func ParseCopyCommandReply(data []byte) (*CopyCommandReply, error) {
	c := new(CopyCommandReply)
	_, err := c.Parse(data)
	if err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CopyCommandReply) encodeBinary() []byte {
	var buf []byte
	buf = append(buf, byte(c.ErrorCode))
	return buf
}

func (c *CopyCommandReply) MarshalBinary() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	return c.encodeBinary(), nil
}

func (c *CopyCommandReply) validate() error {
	return nil
}
